{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This documentation covers the internals of Hyperledger Fabric with a specific focus on chaincode management and support for new Smart Contract languages . While developing the support for writing chaincode in Haskell we had to dive into the implementation details of Fabric and understand not only the peer-chaincode interaction protocol but also the dependencies of this functionality from other subsystems. The exploration and analysis of the code-base and its subsequent sense-making into a more cohesive and structured topic eventually led to this project, which now has a life of its own. Differently from the existing Hyperledger Fabric documentation, which caters more for the end-user and the developer of Smart Contract this documentation covers the internal implementation, its breakdown into subsystems and components, and a detail account of the interactions among them. Therefore, it is quite technical and low-level and primarily addresses the Fabric developer or anyone curious to know how Hyperledger Fabric works, or is tasked to debug it for troubleshooting purposes. Note This documentation would not exist if we didn't venture ourselves into providing support for Haskell as a Smart Contract language. So please check out the fabric-chaincode-haskell project in Github, try it and star it. Where To From Here This documentation is organised into four main sections: Overview : this section provides an overview of the architecture and the key design principles adopted by Hyperledger Fabric to implement the execution and management of smart contracts. It discusses the rationale, benefits, and advantage of the approach and it introduces the key concepts of shim and chaincode stub. Interaction Protocol : this section dives into the details of the chaincode-peer interaction protocol and discusses the various phases of the protocol, from the connection establishment to the execution of transactions. It also provides an overview of the messages exchanged and their meaning. Shim Architecture : this section dives into the implementation of the fabric chaincode shim, which is the process that hosts the smart contract and interfaces it with the Fabric peer. The section discusses the architecture, design, its key components and the protocol used to interact with the peer. If you want to know how GetState , PutState , GetStateByRange and other methods work look in here. Peer Architecture : this section discusses the internal architecture of the peer, its breakdown into subsystems and components. It details how these are involved and participate in the management of the life-cycle of the chaincode and the execution of transactions. If you want to know what happens when a client submits a transaction proposal, look here. Support for New Languages : this section provides an overview of the key components that need to be modified and implemented to enable Hyperledger Fabric with the ability of managing chaincode in another language than Java, Node, or Go. If you want to get to the action and see what takes, jump here. What You Need To Know This documentation assumes that the you have a general understanding of Hyperledger Fabric, its key components, and the transaction execution flow, as a user of this platform. If you need a refresh on these concepts, have a look at the Key Concepts section on the Hyperledger Fabric documentation.","title":"Home"},{"location":"#welcome","text":"This documentation covers the internals of Hyperledger Fabric with a specific focus on chaincode management and support for new Smart Contract languages . While developing the support for writing chaincode in Haskell we had to dive into the implementation details of Fabric and understand not only the peer-chaincode interaction protocol but also the dependencies of this functionality from other subsystems. The exploration and analysis of the code-base and its subsequent sense-making into a more cohesive and structured topic eventually led to this project, which now has a life of its own. Differently from the existing Hyperledger Fabric documentation, which caters more for the end-user and the developer of Smart Contract this documentation covers the internal implementation, its breakdown into subsystems and components, and a detail account of the interactions among them. Therefore, it is quite technical and low-level and primarily addresses the Fabric developer or anyone curious to know how Hyperledger Fabric works, or is tasked to debug it for troubleshooting purposes. Note This documentation would not exist if we didn't venture ourselves into providing support for Haskell as a Smart Contract language. So please check out the fabric-chaincode-haskell project in Github, try it and star it.","title":"Welcome"},{"location":"#where-to-from-here","text":"This documentation is organised into four main sections: Overview : this section provides an overview of the architecture and the key design principles adopted by Hyperledger Fabric to implement the execution and management of smart contracts. It discusses the rationale, benefits, and advantage of the approach and it introduces the key concepts of shim and chaincode stub. Interaction Protocol : this section dives into the details of the chaincode-peer interaction protocol and discusses the various phases of the protocol, from the connection establishment to the execution of transactions. It also provides an overview of the messages exchanged and their meaning. Shim Architecture : this section dives into the implementation of the fabric chaincode shim, which is the process that hosts the smart contract and interfaces it with the Fabric peer. The section discusses the architecture, design, its key components and the protocol used to interact with the peer. If you want to know how GetState , PutState , GetStateByRange and other methods work look in here. Peer Architecture : this section discusses the internal architecture of the peer, its breakdown into subsystems and components. It details how these are involved and participate in the management of the life-cycle of the chaincode and the execution of transactions. If you want to know what happens when a client submits a transaction proposal, look here. Support for New Languages : this section provides an overview of the key components that need to be modified and implemented to enable Hyperledger Fabric with the ability of managing chaincode in another language than Java, Node, or Go. If you want to get to the action and see what takes, jump here.","title":"Where To From Here"},{"location":"#what-you-need-to-know","text":"This documentation assumes that the you have a general understanding of Hyperledger Fabric, its key components, and the transaction execution flow, as a user of this platform. If you need a refresh on these concepts, have a look at the Key Concepts section on the Hyperledger Fabric documentation.","title":"What You Need To Know"},{"location":"about/","text":"About Hi, my name is Christian Vecchiola and I work at IBM Research Australia in the Blockchain team. My team and I did extensive work on Hyperledger Fabric, primarily as users of the framework and lately on integrating new components into the platform. This has led me to get a better understanding of the internals of Hyperledger Fabric and write this guide. Enjoy! More About Me On the Web Github LinkedIn IBM Research","title":"About"},{"location":"about/#about","text":"Hi, my name is Christian Vecchiola and I work at IBM Research Australia in the Blockchain team. My team and I did extensive work on Hyperledger Fabric, primarily as users of the framework and lately on integrating new components into the platform. This has led me to get a better understanding of the internals of Hyperledger Fabric and write this guide. Enjoy!","title":"About"},{"location":"about/#more-about-me-on-the-web","text":"Github LinkedIn IBM Research","title":"More About Me On the Web"},{"location":"license/","text":"License This documentation is released under the Apache License 2.0 Copyright 2020 Christian Vecchiola Licensed under the Apache License , Version 2 . 0 ( the \"License\" ); you may not use this file except in compliance with the License . You may obtain a copy of the License at http : // www . apache . org / licenses / LICENSE - 2 . 0 Unless required by applicable law or agreed to in writing , software distributed under the License is distributed on an \"AS IS\" BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the License for the specific language governing permissions and limitations under the License .","title":"License"},{"location":"license/#license","text":"This documentation is released under the Apache License 2.0 Copyright 2020 Christian Vecchiola Licensed under the Apache License , Version 2 . 0 ( the \"License\" ); you may not use this file except in compliance with the License . You may obtain a copy of the License at http : // www . apache . org / licenses / LICENSE - 2 . 0 Unless required by applicable law or agreed to in writing , software distributed under the License is distributed on an \"AS IS\" BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the License for the specific language governing permissions and limitations under the License .","title":"License"},{"location":"adding-new-languages/","text":"Support for New Languages Work in Progress.","title":"Support for New Languages"},{"location":"adding-new-languages/#support-for-new-languages","text":"Work in Progress.","title":"Support for New Languages"},{"location":"overview/chaincode-execution-model/","text":"Chaincode Execution Model Hyperledger Fabric manages and executes the smart contract deployed through the chaincode as a remote process that interacts with peer via gRPC . This separation of execution environments provides a variety of advantages: Language / tech stack independence : by running the chaincode as a separate process there are far less constraints on the language and tech stack used to write smart contract and the runtime it needs. The interaction point here is defined by the of gRPC services and messages used by the two processes to interact. Currently, this is what enables the Hyperledger Fabric to support other than Golang, both Node and Java as programming languages for smart contract development. Failure isolation : by running the chaincode as a separate process it is possible to constrain the failures (i.e. critical execution errors) to the runtime environemnt associated to that process, without affecting substantially the functionality of the peer. This is particular important, if you think at the smart contract as a plugin that his developed by third parties and it is installed and executed in the Fabric Peer. Deployment flexibility : by running the chaincode as a process we can leverage a variety of deployment models that do not necessarily impose co-location with the peer, the only requirement is for the chaincode and the peer to be able to interact via gRPC. This in principle opens up the possibility to run the chaincode as local OS process, a remote process, a Docker container or any other form of process virtualisation. The current approach is to run it as Docker container. Modular development : separating out the execution of the chaincode into a distinct networked components, increases the modularity of the system as it decouples the chaincode from the peer. This has not only implications on the deployment but also separates out the development of the two. New improvements can be done on the chaincode runtime support implementation without affecting the peer. As a matter of facts, all the chaincode process implementations exist as distinct projects and as a separate repositories, from the Hyperledger Fabric repository. Separation of concerns : this approach also allows to separate what are the functions that are stricly related to the management of the chaincode and the smart contract hosted within it, from the rest of the platform. In order to simplify the life of smart contract developer and focus their effort on the development of the smart contract logic, Hyperledger provides developers with chaincode shims . These are implementation of the runtime environment needed to integrate the smart contract with Hyperledger Fabric and execute them as remote processes. The shim is the component that is responsible to run the smart contract, make it accessible to the peer, manage all the low-level interaction with it via gRPC. Moreover, it provides a simplified interface to the smart contract to access the ledger and chaincode invocation services via chaincode stub . The figure below, provides a very high-level view of the peer-chaincode interaction. Peer Chaincode Interaction Architecture","title":"Chaincode Execution Model"},{"location":"overview/chaincode-execution-model/#chaincode-execution-model","text":"Hyperledger Fabric manages and executes the smart contract deployed through the chaincode as a remote process that interacts with peer via gRPC . This separation of execution environments provides a variety of advantages: Language / tech stack independence : by running the chaincode as a separate process there are far less constraints on the language and tech stack used to write smart contract and the runtime it needs. The interaction point here is defined by the of gRPC services and messages used by the two processes to interact. Currently, this is what enables the Hyperledger Fabric to support other than Golang, both Node and Java as programming languages for smart contract development. Failure isolation : by running the chaincode as a separate process it is possible to constrain the failures (i.e. critical execution errors) to the runtime environemnt associated to that process, without affecting substantially the functionality of the peer. This is particular important, if you think at the smart contract as a plugin that his developed by third parties and it is installed and executed in the Fabric Peer. Deployment flexibility : by running the chaincode as a process we can leverage a variety of deployment models that do not necessarily impose co-location with the peer, the only requirement is for the chaincode and the peer to be able to interact via gRPC. This in principle opens up the possibility to run the chaincode as local OS process, a remote process, a Docker container or any other form of process virtualisation. The current approach is to run it as Docker container. Modular development : separating out the execution of the chaincode into a distinct networked components, increases the modularity of the system as it decouples the chaincode from the peer. This has not only implications on the deployment but also separates out the development of the two. New improvements can be done on the chaincode runtime support implementation without affecting the peer. As a matter of facts, all the chaincode process implementations exist as distinct projects and as a separate repositories, from the Hyperledger Fabric repository. Separation of concerns : this approach also allows to separate what are the functions that are stricly related to the management of the chaincode and the smart contract hosted within it, from the rest of the platform. In order to simplify the life of smart contract developer and focus their effort on the development of the smart contract logic, Hyperledger provides developers with chaincode shims . These are implementation of the runtime environment needed to integrate the smart contract with Hyperledger Fabric and execute them as remote processes. The shim is the component that is responsible to run the smart contract, make it accessible to the peer, manage all the low-level interaction with it via gRPC. Moreover, it provides a simplified interface to the smart contract to access the ledger and chaincode invocation services via chaincode stub . The figure below, provides a very high-level view of the peer-chaincode interaction. Peer Chaincode Interaction Architecture","title":"Chaincode Execution Model"},{"location":"overview/peer-operating-modes/","text":"Peer Operating Modes Hyperledger Fabric provides two different modalities in which the Fabric Peer can be initialised: development and production mode. These two modalities also affects how the interaction between the peer and the chaincode processes is initialised and managed. Regardless of the operating modality the chaincode will still be subject to three the phases: installation onto the peer instantiation in a channel invocation of transactions What changes between the two modalities is how the chaincode process is brought to life and who is responsible for its life-cycle. Production Mode The production mode is the standard modality in which the peer is executed. This modality is designed for production deployments and operates under the assumption that the peer will control the life-cycle of the chaincode process. This operating modality works under the assumption that the environment where the peer is deployed is secured and not easily accessible. The chaincode deployement procedure is more strictly controlled and optimised for ease of operations. In this modality the peer is responsible to initialise and configure the chaincode process as the chaincode is deployed. Only chaincode processes that are spawned by the peer are allowed to interact with and the peer keeps an active registry of all managed processes. During production mode the life-cycle of the chaincode develops as follows: INSTALL : this command upload the chaincode package to the peer, the peer stores a local copy of the package and updates the registry of installed chaincodes. INSTANTIATE : this command triggers the build of the runtime environment for the specified chaincode according to the details defined in the chaincode specification. Once the environment is built the chaincode is launched as docker container and the peer will wait for its connection. Upon connection the peer will invoke the smart contract initialisation function (i.e. Init(ChaincodeStub) ) to setup the chaincode in the specific channel. This operation is performed only once the chaincode is first instantiated in one channel, subsequent instantiation will reuse the runtime environemnt built and already launched. INVOKE : this command triggers the simulation of a transaction proposal, which eventually leads to the invocation of a smart contract function in the remote process running the chaincode, via the dispatch method Invoke(ChaincodeStub) . Development Mode The development mode is designed to improve the development and debugging experience of smart contract developers. In this modalities the peer does not own the chaincode process and it is configure to accept connections from remote processes that identify themselves as installed chaincodes. This allows developers to improve the development iterations as they can control the chaincode process and therefore make updates to its code without installing a new version in the peer or tearing down the entire network. Moreover, they can run the chaincode as a native OS process from their development environment without the need of packaging the smart contract. Because the peer is no longer responsible for the life-cycle of the chaincode process, it is responsibility of the developer to initialise and configure the process to connect to a fabric peer correctly. In this operating modality the phases of the chaincode life-cycle are mapped as follows: INSTALL : this command uploads to the peer the chaincode package, peer stores a local copy of package and updates the registry of the installed chaincodes. INSTANTIATE : this command does not trigger the creation of the runtime environment to run the chaincode but simply deploys the chaincode in a channel, which is done simply by invoking the Init(ChaincodeStub) method on the smart contract implementation running in the chaincode process. INVOKE : this command triggers the simulation of a transaction proposal in the same manner as discussed in the standard operating modality. Because the peer no longer build and launch the chaincode runtime environment, it is necessary for the developer to start the chaincode process and connect it to the peer once the chaincode package has been installed. This is done by starting the chaincode process with the information about the chaincode name and version and the address of the peer. CORE_ID_CHAINCODE_NAME = <name>:<version> CORE_PEER_TLS_ENABLED = false <chaincode-executable-path> -peer.address <host>:<port> The snippet of code above specifies the environment variables that contain the information about the chaincode metadata, the connection mode to the peer, and the hostname and port pair where the peer is accepting connection from chaincode processes. Note, this port is usually different from the port used by application clients to connect to the peer, and by default set to 7052. Note The information specified in the CORE_ID_CHAINCODE_NAME environment variable must match the name and version used in the command peer chaincode install ... to install the chaincode in the peer, otherwise the peer will not be able to identify the chaincode and accept its connection request. More details about how to run the chaincode in development mode can be found in the fabric samples .","title":"Peer Operating Modes"},{"location":"overview/peer-operating-modes/#peer-operating-modes","text":"Hyperledger Fabric provides two different modalities in which the Fabric Peer can be initialised: development and production mode. These two modalities also affects how the interaction between the peer and the chaincode processes is initialised and managed. Regardless of the operating modality the chaincode will still be subject to three the phases: installation onto the peer instantiation in a channel invocation of transactions What changes between the two modalities is how the chaincode process is brought to life and who is responsible for its life-cycle.","title":"Peer Operating Modes"},{"location":"overview/peer-operating-modes/#production-mode","text":"The production mode is the standard modality in which the peer is executed. This modality is designed for production deployments and operates under the assumption that the peer will control the life-cycle of the chaincode process. This operating modality works under the assumption that the environment where the peer is deployed is secured and not easily accessible. The chaincode deployement procedure is more strictly controlled and optimised for ease of operations. In this modality the peer is responsible to initialise and configure the chaincode process as the chaincode is deployed. Only chaincode processes that are spawned by the peer are allowed to interact with and the peer keeps an active registry of all managed processes. During production mode the life-cycle of the chaincode develops as follows: INSTALL : this command upload the chaincode package to the peer, the peer stores a local copy of the package and updates the registry of installed chaincodes. INSTANTIATE : this command triggers the build of the runtime environment for the specified chaincode according to the details defined in the chaincode specification. Once the environment is built the chaincode is launched as docker container and the peer will wait for its connection. Upon connection the peer will invoke the smart contract initialisation function (i.e. Init(ChaincodeStub) ) to setup the chaincode in the specific channel. This operation is performed only once the chaincode is first instantiated in one channel, subsequent instantiation will reuse the runtime environemnt built and already launched. INVOKE : this command triggers the simulation of a transaction proposal, which eventually leads to the invocation of a smart contract function in the remote process running the chaincode, via the dispatch method Invoke(ChaincodeStub) .","title":"Production Mode"},{"location":"overview/peer-operating-modes/#development-mode","text":"The development mode is designed to improve the development and debugging experience of smart contract developers. In this modalities the peer does not own the chaincode process and it is configure to accept connections from remote processes that identify themselves as installed chaincodes. This allows developers to improve the development iterations as they can control the chaincode process and therefore make updates to its code without installing a new version in the peer or tearing down the entire network. Moreover, they can run the chaincode as a native OS process from their development environment without the need of packaging the smart contract. Because the peer is no longer responsible for the life-cycle of the chaincode process, it is responsibility of the developer to initialise and configure the process to connect to a fabric peer correctly. In this operating modality the phases of the chaincode life-cycle are mapped as follows: INSTALL : this command uploads to the peer the chaincode package, peer stores a local copy of package and updates the registry of the installed chaincodes. INSTANTIATE : this command does not trigger the creation of the runtime environment to run the chaincode but simply deploys the chaincode in a channel, which is done simply by invoking the Init(ChaincodeStub) method on the smart contract implementation running in the chaincode process. INVOKE : this command triggers the simulation of a transaction proposal in the same manner as discussed in the standard operating modality. Because the peer no longer build and launch the chaincode runtime environment, it is necessary for the developer to start the chaincode process and connect it to the peer once the chaincode package has been installed. This is done by starting the chaincode process with the information about the chaincode name and version and the address of the peer. CORE_ID_CHAINCODE_NAME = <name>:<version> CORE_PEER_TLS_ENABLED = false <chaincode-executable-path> -peer.address <host>:<port> The snippet of code above specifies the environment variables that contain the information about the chaincode metadata, the connection mode to the peer, and the hostname and port pair where the peer is accepting connection from chaincode processes. Note, this port is usually different from the port used by application clients to connect to the peer, and by default set to 7052. Note The information specified in the CORE_ID_CHAINCODE_NAME environment variable must match the name and version used in the command peer chaincode install ... to install the chaincode in the peer, otherwise the peer will not be able to identify the chaincode and accept its connection request. More details about how to run the chaincode in development mode can be found in the fabric samples .","title":"Development Mode"},{"location":"overview/secure-networking/","text":"Securing Peer Chaincode Interactions The Chaincode process and the Peer interact over a GRPC connection, this communication can be secured with TLS since it may occur over an insecure network. There are a variety of attacks that may occur if the network is unsecure: Eavesdropping : made possible by someone spoofing the GRPC connection and observing the invocation of transactions as well as the proposal responses. Peer Impersonation Attacks : this can be achieved by altering the configuration of the chaincode process and luring it to connect to a malicious process pretending to be the peer. Chaincode Impersonation Attacks : this can be achieved by luring the peer into believing that the connected process is a legitimate chaincode, but instead it is malicious process. All these attacks have different effects and either provide visibility to information that may be confidential and cause damage to the network by introducing a malicious entity in the network. In order to prevent these attacks as of Hyperledger Fabric release 1.4 there are a number of measures that have been introduced: Distinct Chaincode Support Service for the Peer (host:port). TLS Support for the Interaction Chaincode-Peer. Dynamically Configurable Client Certificates for the Chaincode Process. The first two measures work in concert with the network architecture to protect and address mostly the first two attacks. The third approach, combined with the previous two, is used to prevent chaincode impersonation attacks. Distinct Chaincode Support Service for the Peer (host:port) This measure is effective if combined with the propert network architecture in production environments. It separates the communication between the chaincode process and the peer on different address (host:port) of the peer. This separation allows for setting up a private and secure network where the chaincode process is deployed, thus making inaccessible to entities other than the peer the chaincode process. This measure is as effective as the security of the private network it relies upon. If the network is secure and not accessible to others an attacker needs to first gain access to the secure network to perform any of the attacks. There are two configuration parameters that control this setting: chaincodeListenAddress : this is the property in the YAML configuration file of the peer that determines where the peer expects to receive connection from chaincode processes. chaincodeAddress : this is the property in the YAML configuration file used by the chaincode process spawned by the peer to connect to the peer. The second parameter is optional and defaults to chaincodeListenAddress if not specified. If this is not specified it will be set to the listen address of the peer. Note This setup does not apply to the development mode, which is not considered a production deployment and it is designed to provide access to external agents (e.g. the developer) to the network used to connect the chaincode process and the peer. TLS Support for the Interaction Chaincode-Peer This measure ensures that the chaincode process knows the identity of the Peer it is going to connect to and can veify it during the setup of the initial connection. Again, this measure is as good as the security of the network architecture of the peer deployment. In order for it to work it requires that the TLS certificate of the Peer provided to the chaincode process cannot be accessed, manipulated, or substituted with a malicious one. In a production operation mode the likelyhood of manipulating the chaincode process configuration is significantly reduced: the chaincode proces life-cycle is managed by the peer and therefore compromising the chaincode configuraiton would require compromising the peer itself. Dynamically Configurable Client Certificates for the Chaincode Process This measure ensures that while operating in production mode, the peer does not accept connections that do not provide a client certificate associated to a chaincode container previously launched. The client certificates are created when the runtime environment for the chaincode is built and injected into it. Moreover, each of these certificates has a time window associated to it, to minimise the exposure of peer to malicious connections that have managed to access the client certificate. This measure works in conjunction with the previous two as it requires a TLS setup and it is further secured by having a separate address to accept connections from the chaincode processes. With these measures in place it would become very hard for an attacker to impersonate a chaincode process: it would require to compromise the peer and access the dynamically created certificate or eventually access the chaincode container after its launch to steal the certificate.","title":"Secure Networking"},{"location":"overview/secure-networking/#securing-peer-chaincode-interactions","text":"The Chaincode process and the Peer interact over a GRPC connection, this communication can be secured with TLS since it may occur over an insecure network. There are a variety of attacks that may occur if the network is unsecure: Eavesdropping : made possible by someone spoofing the GRPC connection and observing the invocation of transactions as well as the proposal responses. Peer Impersonation Attacks : this can be achieved by altering the configuration of the chaincode process and luring it to connect to a malicious process pretending to be the peer. Chaincode Impersonation Attacks : this can be achieved by luring the peer into believing that the connected process is a legitimate chaincode, but instead it is malicious process. All these attacks have different effects and either provide visibility to information that may be confidential and cause damage to the network by introducing a malicious entity in the network. In order to prevent these attacks as of Hyperledger Fabric release 1.4 there are a number of measures that have been introduced: Distinct Chaincode Support Service for the Peer (host:port). TLS Support for the Interaction Chaincode-Peer. Dynamically Configurable Client Certificates for the Chaincode Process. The first two measures work in concert with the network architecture to protect and address mostly the first two attacks. The third approach, combined with the previous two, is used to prevent chaincode impersonation attacks.","title":"Securing Peer Chaincode Interactions"},{"location":"overview/secure-networking/#distinct-chaincode-support-service-for-the-peer-hostport","text":"This measure is effective if combined with the propert network architecture in production environments. It separates the communication between the chaincode process and the peer on different address (host:port) of the peer. This separation allows for setting up a private and secure network where the chaincode process is deployed, thus making inaccessible to entities other than the peer the chaincode process. This measure is as effective as the security of the private network it relies upon. If the network is secure and not accessible to others an attacker needs to first gain access to the secure network to perform any of the attacks. There are two configuration parameters that control this setting: chaincodeListenAddress : this is the property in the YAML configuration file of the peer that determines where the peer expects to receive connection from chaincode processes. chaincodeAddress : this is the property in the YAML configuration file used by the chaincode process spawned by the peer to connect to the peer. The second parameter is optional and defaults to chaincodeListenAddress if not specified. If this is not specified it will be set to the listen address of the peer. Note This setup does not apply to the development mode, which is not considered a production deployment and it is designed to provide access to external agents (e.g. the developer) to the network used to connect the chaincode process and the peer.","title":"Distinct Chaincode Support Service for the Peer (host:port)"},{"location":"overview/secure-networking/#tls-support-for-the-interaction-chaincode-peer","text":"This measure ensures that the chaincode process knows the identity of the Peer it is going to connect to and can veify it during the setup of the initial connection. Again, this measure is as good as the security of the network architecture of the peer deployment. In order for it to work it requires that the TLS certificate of the Peer provided to the chaincode process cannot be accessed, manipulated, or substituted with a malicious one. In a production operation mode the likelyhood of manipulating the chaincode process configuration is significantly reduced: the chaincode proces life-cycle is managed by the peer and therefore compromising the chaincode configuraiton would require compromising the peer itself.","title":"TLS Support for the Interaction Chaincode-Peer"},{"location":"overview/secure-networking/#dynamically-configurable-client-certificates-for-the-chaincode-process","text":"This measure ensures that while operating in production mode, the peer does not accept connections that do not provide a client certificate associated to a chaincode container previously launched. The client certificates are created when the runtime environment for the chaincode is built and injected into it. Moreover, each of these certificates has a time window associated to it, to minimise the exposure of peer to malicious connections that have managed to access the client certificate. This measure works in conjunction with the previous two as it requires a TLS setup and it is further secured by having a separate address to accept connections from the chaincode processes. With these measures in place it would become very hard for an attacker to impersonate a chaincode process: it would require to compromise the peer and access the dynamically created certificate or eventually access the chaincode container after its launch to steal the certificate.","title":"Dynamically Configurable Client Certificates for the Chaincode Process"},{"location":"peer-architecture/","text":"Fabric Peer Architecture Work in Progress.","title":"Peer Architecture"},{"location":"peer-architecture/#fabric-peer-architecture","text":"Work in Progress.","title":"Fabric Peer Architecture"},{"location":"protocol/architecture-components/","text":"Key Components The figure below provides an overview of the principal components that are involved in the interaction between the chaincode process and the peer. Key Architectural Components for Peer Chaincode Interaction The protocol is implemented as an exchange of GRPC messages between the GRPC server on the peer and the GRPC client in the chaincode process. The GRPC server exposes the ChaincodeSupport service. The protobuf definition of this service is found in the chaincode_shim.proto file in the hyperledger fabric distribution repository. The service exposes only one method Register which opens a bidirectional stream between the chaincode and the peer. This is the channel where the exchange of messages happens. Note This interaction modality is also called chaincode as client , which is the only interaction mode available until Hyperledger Fabric 2.0. The implementation of the fabric shim for go chaincode also allows the initialisation of the chaincode process as a server in the message exchange between the two. This modality is known as chaincode as server but it is not in use until version 2.0 of Hyperledger Fabric. Peer Components In the peer, the ChaincodeSupport service is mapped to the ChaincodeSupportServer interface. This is implemented by the ChaincodeSupport struct, which is the point of connection between the other components of the peers and the communication channel with the chaincode process. The ChaincodeSupport struct manages the connection and the interaction with all the chaincode processes. The listing below shows the attribute the struct. type ChaincodeSupport struct { Keepalive time . Duration ExecuteTimeout time . Duration UserRunsCC bool Runtime Runtime ACLProvider ACLProvider HandlerRegistry * HandlerRegistry Launcher Launcher SystemCCProvider sysccprovider . SystemChaincodeProvider Lifecycle Lifecycle appConfig ApplicationConfigRetriever HandlerMetrics * HandlerMetrics LaunchMetrics * LaunchMetrics } This struct is the main entry point for the management of the chaincode processes within the peer. There are three main functions that this component performs: Chaincode Runtime Environment Management : this means building, starting up, and managing the runtime environment where the smart contract are executed (i.e. Runime and Launcher ). Chaincode Interaction Protocol Management : this entails management of the connection with the chaincode processes and implementing the interaction protocol. Most of the functionalities are managed by the collection of Handler instances, one per chaincode process, that provide services to the smart contract such as ledger access and cross-chaincode invocations. Transaction Simulation : this entails forwarding transaction proposals to the appropriate chaincode process along with the required channel context to allow the smart contract to simulate the execution and provide results. Again, this capability is delegated to the associated Handler that manages the interaction with a specific chaincode process. Transactions simulations are initiated by application clients that submit transaction proposal through the EndorserServer GRPC service. The code listing below shows the details of the protobuf definition. The service has only one method ProcessProposal(....) . service Endorser { rpc ProcessProposal ( SignedProposal ) returns ( ProposalResponse ) {} } The bindings for this service are represented by the Endorser component. This component coordinates the execution of the transaction simulation by interacting with the ChaincodeSupport instance previously discussed. Note As shown in the figure the Endorser has a Support component which is the liason to the ChaincodeSupport instance previously discussed. For more details about these components see the Peer Architecture section. Chaincode Components The chaincode process contain a shim (i.e. shim.go ), which is the main driver of the process and it is responsible for the coordination with the peer. The shim is initialised with an implementation of the Chaincode interface, which represents the smart contract hosted and executed in the process. The connectivity with the peer is managed by the GRPC client which is used to retrieve a bidirectional stream used by the Handler . This component implements the interaction protocol with the peer and exchange ChaincodeMessage instances as a result of: the invocation of transactions by the peer; and ledger queries or cross chaincode invocations by the smart contract. For more details about these components see the Shim Architecture section.","title":"Key Components"},{"location":"protocol/architecture-components/#key-components","text":"The figure below provides an overview of the principal components that are involved in the interaction between the chaincode process and the peer. Key Architectural Components for Peer Chaincode Interaction The protocol is implemented as an exchange of GRPC messages between the GRPC server on the peer and the GRPC client in the chaincode process. The GRPC server exposes the ChaincodeSupport service. The protobuf definition of this service is found in the chaincode_shim.proto file in the hyperledger fabric distribution repository. The service exposes only one method Register which opens a bidirectional stream between the chaincode and the peer. This is the channel where the exchange of messages happens. Note This interaction modality is also called chaincode as client , which is the only interaction mode available until Hyperledger Fabric 2.0. The implementation of the fabric shim for go chaincode also allows the initialisation of the chaincode process as a server in the message exchange between the two. This modality is known as chaincode as server but it is not in use until version 2.0 of Hyperledger Fabric.","title":"Key Components"},{"location":"protocol/architecture-components/#peer-components","text":"In the peer, the ChaincodeSupport service is mapped to the ChaincodeSupportServer interface. This is implemented by the ChaincodeSupport struct, which is the point of connection between the other components of the peers and the communication channel with the chaincode process. The ChaincodeSupport struct manages the connection and the interaction with all the chaincode processes. The listing below shows the attribute the struct. type ChaincodeSupport struct { Keepalive time . Duration ExecuteTimeout time . Duration UserRunsCC bool Runtime Runtime ACLProvider ACLProvider HandlerRegistry * HandlerRegistry Launcher Launcher SystemCCProvider sysccprovider . SystemChaincodeProvider Lifecycle Lifecycle appConfig ApplicationConfigRetriever HandlerMetrics * HandlerMetrics LaunchMetrics * LaunchMetrics } This struct is the main entry point for the management of the chaincode processes within the peer. There are three main functions that this component performs: Chaincode Runtime Environment Management : this means building, starting up, and managing the runtime environment where the smart contract are executed (i.e. Runime and Launcher ). Chaincode Interaction Protocol Management : this entails management of the connection with the chaincode processes and implementing the interaction protocol. Most of the functionalities are managed by the collection of Handler instances, one per chaincode process, that provide services to the smart contract such as ledger access and cross-chaincode invocations. Transaction Simulation : this entails forwarding transaction proposals to the appropriate chaincode process along with the required channel context to allow the smart contract to simulate the execution and provide results. Again, this capability is delegated to the associated Handler that manages the interaction with a specific chaincode process. Transactions simulations are initiated by application clients that submit transaction proposal through the EndorserServer GRPC service. The code listing below shows the details of the protobuf definition. The service has only one method ProcessProposal(....) . service Endorser { rpc ProcessProposal ( SignedProposal ) returns ( ProposalResponse ) {} } The bindings for this service are represented by the Endorser component. This component coordinates the execution of the transaction simulation by interacting with the ChaincodeSupport instance previously discussed. Note As shown in the figure the Endorser has a Support component which is the liason to the ChaincodeSupport instance previously discussed. For more details about these components see the Peer Architecture section.","title":"Peer Components"},{"location":"protocol/architecture-components/#chaincode-components","text":"The chaincode process contain a shim (i.e. shim.go ), which is the main driver of the process and it is responsible for the coordination with the peer. The shim is initialised with an implementation of the Chaincode interface, which represents the smart contract hosted and executed in the process. The connectivity with the peer is managed by the GRPC client which is used to retrieve a bidirectional stream used by the Handler . This component implements the interaction protocol with the peer and exchange ChaincodeMessage instances as a result of: the invocation of transactions by the peer; and ledger queries or cross chaincode invocations by the smart contract. For more details about these components see the Shim Architecture section.","title":"Chaincode Components"},{"location":"protocol/interaction-lifecycle/","text":"Interaction Lifecycle The interaction protocol is completely based on the exchange of Protobuf messages between the chaincode process and the peer. The exchanged messages are of type ChaincodeMessage and defined in the chaincode_shim.proto file of the fabric-protos repository. The advantage of using Protobuf is to decouple the semantic from the implementation. Protocol Interaction Overview The figure above provides an overview of the interaction protocol end-to-end. The lifecycle of the interaction develops in three phases: initialisation, setup, and transaction execution (or run phase). More details for each of the phases will be provided in the corresponding sections. Message Structure The table below provides an overview of the structure of the message. The design rationale is to use a single type of message whose type determines how to interpret and cast the payload. Different types of messages are used to express and convey the information needed for each of the operations supported by the protocol. Attribute Name Type Meaning Optional Comments type enum type of message no timestamp google.protobuf.Timestamp timestamp no message creation time txid string transaction identifier yes payload byte[] message payload yes contains different information based on type proposal SignedProposal signed transaction proposal yes contains the transaction proposal to simulate chaincode_event ChaincoodeEvent chaincode event to be raised at commit time yes set by the chaincode shim if events need to be raised channel_id string channel unique identifier yes specifies the channel the transaction belongs to Note The types ChaincodeEvent and SignedProposal are defined in the files chaincoode_event.proto and proposal.proto in the same repository. Phase 1: Initialisation Peer Initialisation The peer node is made up by several sub-systems that collectively provide services to the Hyperledger Fabric network (see: Peer Architecture for more details). In this context we focus on those components that are relevant to the interaction with the chaincode process. The following steps are executed: PlatformRegistry initialisation: this component provide saccess to the chaincode builsing and launching services for supported stacks (i.e. golang, jvascript, java, ...). ChaincodeProvider iniitialisation: this component provides access to the chaincode packaging capability (primarily transaction execution). ChaincodeSupport initialisation: thhis component porivde access to the chaincode services at the peer level. ChaincodeSupportServer initialisation: this component is the GRPC server that exposes the ChaincodeSupport service and accepts the connection from the chaincode processes. EndorserServer initialisation: this component is the GRPC server that exposes the EndorserSupport service which receives transaction proposal for endorsement. The endorsement entails the execution of a transaction simulation in one of the connected chaincode processes. Shim Initialisation The driver process of the shim loads the chaincode by invoking shim.Start(Chaincode) . This method performs the following operations: GRPC client initialisation: this is used to connect to the peer and setup a bidirectional stream to exchange ChaincodeMessage instances. Handler initialisation: this component is in charge of processing all the messages sent by the peer and execute the associate operations. Messaging processing loop initialisation: this message loop is used to receive the messages from the peer and dispatch them to the handler for further processing. This initialisation modality support the chaincode-as-client pattern, where the chaincode process is a client to the peer. The shim also has the capability to initialise itself to support the chaincode_as_server pattern, where the roles are reversed. This is done by initialising a new ChaincodeServer instance with the details of the chaincode and invoke the method ChaincodeServer.Start() . Phase 2: Communication Setup Before starting the messaging processing loop the shim sends a REGISTER message through the bidirectional stream opened with the peer. This message contains the details of the chaincode to register codified as a ChaincodeID in the payload. Upon reception of the message, the peer validates the information associated to the chaincode and allocates an Handler instance to manage the message exchange with the chaincode process. The peer then responds with a REGISTERED message and immediately after with a READY message, signaling the completion of the setup process. The figure below shows the exchange of messages during the setup phase, with reference to the chaincode shim implemented in Go. Message Exchange During Setup Phase Phase 3: Transaction Execution Once the setup phase is complete the chaincode and peer are ready to run transactions. From this point onward the interaction is driven by the peer, as a result of the operations that are submitted ted by the application clients to the peer. These usually involve the deployment of the chaincode onto a specific channel and the subsequent invocation of transactions on the deployed smart contract. This interaction is implemented in the following steps: As a result of a chaincode deployment, the peer sends an INIT message. This operation is triggered by the invocation of the ChaincodeSupport.InvokeInit(...) method, which calls the Handler.Execute(...) method on the instance that is mapped to the chaincode being invoked. The handle initialises a Transaction Context for the simulation of the transaction proposal associated to the initialisation and sends the message through bidirectional stream. Upon reception of the INIT message the message receiving loop dispatches the message to the Handler . This in turn creates a new ChaincodeStub instance, which represents the interface to the peer services exposed to the smart contract, and invokes Chaincode.Init(...) by passing the stub as argument. This invocation is executed in a separate go-routine, thus preventing the chaincode from blocking the message receiving loop. The chaincode executes the initialisation of the initialisation of the smart contract and the Init(...) method completes either successfully or with an error. The former causes a COMPLETED message to be sent back to the peer, while the latter triggers an ERROR message. Upon reception of the message, the message receiving loop of the peer invokes the Handler.Notify(...) method on the instance associated to the chaincode process. This method closes the previously open transaction context and causes the Handler.Execute(...) method to unblock and return the response obtained by the chaincode to the caller. Subsequent invocations of the same chaincode in the same channel, result in the peer sending a TRANSACTION message, which is handled in the same manner as detailed for the INIT message. The figure below summarises the interactions among components that happens both within the peer and the chaincode shim. Occasionally, and if configured to do so, the peer sends KEEP_ALIVE messages that the chaincode process simply replies to, to ensure that the shim is still alive. This is particularly relevant in a deployment where the transactions are infrequent. Message Exchange During Run Phase The processing of an INIT or TRANSACTION message, may require the chaincode process to access the ledger or invoke another chaincode onto the same peer. This results in one or more messages sent back to the peer within the context of the communication established by the INIT or TRANSACTION message. The figure below shows how the previous interaction changes in case of talk-backs. Message Exchange During Run Phase with Callbacks The communication back to the peer is exercised by invoking one of the methods exposed by the ChaincodeStubInterface and implemented in the ChaincodeStub . For those methods that require a talk back the Handler sets up a response channel which is used by the current go-routine processing the original INIT or TRANSACTION method to send the message to the peer and wait for the response. The specific type and payload of the message sent to the peer depends upon the method that has been invoked on the stub (for more details see the Message Types section). On the peer side, when the message is received the corresponding operation is performed and the result is sent back through a RESPONSE (or ERROR ) message. This message is picked up by the message receiving loop of the chaincode shim, which dispatches it to the Handleer . By using the information in the message, the handler selects the associated response channel and sends the message through it, thus unblocking the waiting go-routine that can now continue its processing with the received results. The figure shows only one communication back to the peer, but this process can be executed multiple times. One for any invocation on the ChaincodeStubInterface that requires talking back to the peer. Once the smart contract has completed the processing a COMPLETED (or ERROR ) message willn be sent back to the peer, thus terminating the transaction simulation.","title":"Interaction Lifecycle"},{"location":"protocol/interaction-lifecycle/#interaction-lifecycle","text":"The interaction protocol is completely based on the exchange of Protobuf messages between the chaincode process and the peer. The exchanged messages are of type ChaincodeMessage and defined in the chaincode_shim.proto file of the fabric-protos repository. The advantage of using Protobuf is to decouple the semantic from the implementation. Protocol Interaction Overview The figure above provides an overview of the interaction protocol end-to-end. The lifecycle of the interaction develops in three phases: initialisation, setup, and transaction execution (or run phase). More details for each of the phases will be provided in the corresponding sections.","title":"Interaction Lifecycle"},{"location":"protocol/interaction-lifecycle/#message-structure","text":"The table below provides an overview of the structure of the message. The design rationale is to use a single type of message whose type determines how to interpret and cast the payload. Different types of messages are used to express and convey the information needed for each of the operations supported by the protocol. Attribute Name Type Meaning Optional Comments type enum type of message no timestamp google.protobuf.Timestamp timestamp no message creation time txid string transaction identifier yes payload byte[] message payload yes contains different information based on type proposal SignedProposal signed transaction proposal yes contains the transaction proposal to simulate chaincode_event ChaincoodeEvent chaincode event to be raised at commit time yes set by the chaincode shim if events need to be raised channel_id string channel unique identifier yes specifies the channel the transaction belongs to Note The types ChaincodeEvent and SignedProposal are defined in the files chaincoode_event.proto and proposal.proto in the same repository.","title":"Message Structure"},{"location":"protocol/interaction-lifecycle/#phase-1-initialisation","text":"","title":"Phase 1: Initialisation"},{"location":"protocol/interaction-lifecycle/#peer-initialisation","text":"The peer node is made up by several sub-systems that collectively provide services to the Hyperledger Fabric network (see: Peer Architecture for more details). In this context we focus on those components that are relevant to the interaction with the chaincode process. The following steps are executed: PlatformRegistry initialisation: this component provide saccess to the chaincode builsing and launching services for supported stacks (i.e. golang, jvascript, java, ...). ChaincodeProvider iniitialisation: this component provides access to the chaincode packaging capability (primarily transaction execution). ChaincodeSupport initialisation: thhis component porivde access to the chaincode services at the peer level. ChaincodeSupportServer initialisation: this component is the GRPC server that exposes the ChaincodeSupport service and accepts the connection from the chaincode processes. EndorserServer initialisation: this component is the GRPC server that exposes the EndorserSupport service which receives transaction proposal for endorsement. The endorsement entails the execution of a transaction simulation in one of the connected chaincode processes.","title":"Peer Initialisation"},{"location":"protocol/interaction-lifecycle/#shim-initialisation","text":"The driver process of the shim loads the chaincode by invoking shim.Start(Chaincode) . This method performs the following operations: GRPC client initialisation: this is used to connect to the peer and setup a bidirectional stream to exchange ChaincodeMessage instances. Handler initialisation: this component is in charge of processing all the messages sent by the peer and execute the associate operations. Messaging processing loop initialisation: this message loop is used to receive the messages from the peer and dispatch them to the handler for further processing. This initialisation modality support the chaincode-as-client pattern, where the chaincode process is a client to the peer. The shim also has the capability to initialise itself to support the chaincode_as_server pattern, where the roles are reversed. This is done by initialising a new ChaincodeServer instance with the details of the chaincode and invoke the method ChaincodeServer.Start() .","title":"Shim Initialisation"},{"location":"protocol/interaction-lifecycle/#phase-2-communication-setup","text":"Before starting the messaging processing loop the shim sends a REGISTER message through the bidirectional stream opened with the peer. This message contains the details of the chaincode to register codified as a ChaincodeID in the payload. Upon reception of the message, the peer validates the information associated to the chaincode and allocates an Handler instance to manage the message exchange with the chaincode process. The peer then responds with a REGISTERED message and immediately after with a READY message, signaling the completion of the setup process. The figure below shows the exchange of messages during the setup phase, with reference to the chaincode shim implemented in Go. Message Exchange During Setup Phase","title":"Phase 2: Communication Setup"},{"location":"protocol/interaction-lifecycle/#phase-3-transaction-execution","text":"Once the setup phase is complete the chaincode and peer are ready to run transactions. From this point onward the interaction is driven by the peer, as a result of the operations that are submitted ted by the application clients to the peer. These usually involve the deployment of the chaincode onto a specific channel and the subsequent invocation of transactions on the deployed smart contract. This interaction is implemented in the following steps: As a result of a chaincode deployment, the peer sends an INIT message. This operation is triggered by the invocation of the ChaincodeSupport.InvokeInit(...) method, which calls the Handler.Execute(...) method on the instance that is mapped to the chaincode being invoked. The handle initialises a Transaction Context for the simulation of the transaction proposal associated to the initialisation and sends the message through bidirectional stream. Upon reception of the INIT message the message receiving loop dispatches the message to the Handler . This in turn creates a new ChaincodeStub instance, which represents the interface to the peer services exposed to the smart contract, and invokes Chaincode.Init(...) by passing the stub as argument. This invocation is executed in a separate go-routine, thus preventing the chaincode from blocking the message receiving loop. The chaincode executes the initialisation of the initialisation of the smart contract and the Init(...) method completes either successfully or with an error. The former causes a COMPLETED message to be sent back to the peer, while the latter triggers an ERROR message. Upon reception of the message, the message receiving loop of the peer invokes the Handler.Notify(...) method on the instance associated to the chaincode process. This method closes the previously open transaction context and causes the Handler.Execute(...) method to unblock and return the response obtained by the chaincode to the caller. Subsequent invocations of the same chaincode in the same channel, result in the peer sending a TRANSACTION message, which is handled in the same manner as detailed for the INIT message. The figure below summarises the interactions among components that happens both within the peer and the chaincode shim. Occasionally, and if configured to do so, the peer sends KEEP_ALIVE messages that the chaincode process simply replies to, to ensure that the shim is still alive. This is particularly relevant in a deployment where the transactions are infrequent. Message Exchange During Run Phase The processing of an INIT or TRANSACTION message, may require the chaincode process to access the ledger or invoke another chaincode onto the same peer. This results in one or more messages sent back to the peer within the context of the communication established by the INIT or TRANSACTION message. The figure below shows how the previous interaction changes in case of talk-backs. Message Exchange During Run Phase with Callbacks The communication back to the peer is exercised by invoking one of the methods exposed by the ChaincodeStubInterface and implemented in the ChaincodeStub . For those methods that require a talk back the Handler sets up a response channel which is used by the current go-routine processing the original INIT or TRANSACTION method to send the message to the peer and wait for the response. The specific type and payload of the message sent to the peer depends upon the method that has been invoked on the stub (for more details see the Message Types section). On the peer side, when the message is received the corresponding operation is performed and the result is sent back through a RESPONSE (or ERROR ) message. This message is picked up by the message receiving loop of the chaincode shim, which dispatches it to the Handleer . By using the information in the message, the handler selects the associated response channel and sends the message through it, thus unblocking the waiting go-routine that can now continue its processing with the received results. The figure shows only one communication back to the peer, but this process can be executed multiple times. One for any invocation on the ChaincodeStubInterface that requires talking back to the peer. Once the smart contract has completed the processing a COMPLETED (or ERROR ) message willn be sent back to the peer, thus terminating the transaction simulation.","title":"Phase 3: Transaction Execution"},{"location":"protocol/messages/","text":"Protocol Messages Overview The table below shows a mapping to the of the various message types to the corresponding type of payloads that the protocol use to exchange information. Intuitively, the name of the constant of the message type provides insights on what type of information the payload conveys and what type of operation it is associated to. Message Type Byte Value Meaning Sent By Payload Type UNDEFINED 0 Identifies an unrecognised message (default value for type). N/A NIL (not relevant) REGISTER 1 Registers a chaincode process with the peer. shim ChaincodeID REGISTERED 2 Acknowledges the registration of the chaincode process. peer NIL INIT 3 Initialises the chaincode in the specified channel. peer ChaincodeInput READY 4 Communicates to the chaincode to enter the ready state. peer NIL TRANSACTION 5 Invokes a transaction (smart contract method). peer ChaincodeInput COMPLETED 6 Successful response to an INIT or TRANSACTION message. shim Response ERROR 7 Communicates an error, as a result of the processing of a previous message. both Varies (e.g. Error, string) GET_STATE 8 Retrieves the value for the specified state (i.e. key). shim GetState PUT_STATE 9 Sets the value for the specified state (i.e. key). shim PutState DEL_STATE 10 Removes the value for the specified key from the current view of the ledger. shim DelState INVOKE_CHAINCODE 11 Invokes a chaincode installed on the same peer and deployed on a channel. peer ChaincodeSpec RESPONSE 13 Responds to a chaincode invocation or a ledger request. peer Varies based on type of message replied GET_STATE_BY_RANGE 14 Retrieves the values for a subset of the keys. shim GetStateByRange GET_QUERY_RESULT 15 Performs a rich query against the ledger database. shim GetQueryResult QUERY_STATE_NEXT 16 Retrieves the next page of keys from the resultset. shim QueryResponse QUERY_STATE_CLOSE 17 Closes the iteration over the states of the rich query. shim QueryResponse KEEPALIVE 18 Keep alive message sent by the peer and replied by the shim. both NIL GET_HISTORY_FOR_KEY 19 Retrieves the historical values of a given key. shim GetHistoryForKey GET_STATE_METADATA 20 Retrieves the state metadata (used for state-based endorsements). shim GetStateMetadata PUT_STATE_METADATA 21 Sets the state metadata (used for state-based endorsements). shim PutStateMetadata GET_PRIVATE_DATA_HASH 22 Retrieves the hash of the value associated to the key in a private collection. shim GetState","title":"Messages Exchanged"},{"location":"protocol/messages/#protocol-messages-overview","text":"The table below shows a mapping to the of the various message types to the corresponding type of payloads that the protocol use to exchange information. Intuitively, the name of the constant of the message type provides insights on what type of information the payload conveys and what type of operation it is associated to. Message Type Byte Value Meaning Sent By Payload Type UNDEFINED 0 Identifies an unrecognised message (default value for type). N/A NIL (not relevant) REGISTER 1 Registers a chaincode process with the peer. shim ChaincodeID REGISTERED 2 Acknowledges the registration of the chaincode process. peer NIL INIT 3 Initialises the chaincode in the specified channel. peer ChaincodeInput READY 4 Communicates to the chaincode to enter the ready state. peer NIL TRANSACTION 5 Invokes a transaction (smart contract method). peer ChaincodeInput COMPLETED 6 Successful response to an INIT or TRANSACTION message. shim Response ERROR 7 Communicates an error, as a result of the processing of a previous message. both Varies (e.g. Error, string) GET_STATE 8 Retrieves the value for the specified state (i.e. key). shim GetState PUT_STATE 9 Sets the value for the specified state (i.e. key). shim PutState DEL_STATE 10 Removes the value for the specified key from the current view of the ledger. shim DelState INVOKE_CHAINCODE 11 Invokes a chaincode installed on the same peer and deployed on a channel. peer ChaincodeSpec RESPONSE 13 Responds to a chaincode invocation or a ledger request. peer Varies based on type of message replied GET_STATE_BY_RANGE 14 Retrieves the values for a subset of the keys. shim GetStateByRange GET_QUERY_RESULT 15 Performs a rich query against the ledger database. shim GetQueryResult QUERY_STATE_NEXT 16 Retrieves the next page of keys from the resultset. shim QueryResponse QUERY_STATE_CLOSE 17 Closes the iteration over the states of the rich query. shim QueryResponse KEEPALIVE 18 Keep alive message sent by the peer and replied by the shim. both NIL GET_HISTORY_FOR_KEY 19 Retrieves the historical values of a given key. shim GetHistoryForKey GET_STATE_METADATA 20 Retrieves the state metadata (used for state-based endorsements). shim GetStateMetadata PUT_STATE_METADATA 21 Sets the state metadata (used for state-based endorsements). shim PutStateMetadata GET_PRIVATE_DATA_HASH 22 Retrieves the hash of the value associated to the key in a private collection. shim GetState","title":"Protocol Messages Overview"},{"location":"shim-architecture/","text":"Fabric Chaincode Shim Architecture The figure below provides breakdown of the components that make up the chaincode process together with the role and responsibilities that each of the components have. It is worth noting, that while the shim is a specific component of the chaincode process, unless differently specified the shim is also used to refer to the set of components that make up the chaincode process except for the implementation of the chaincode interface, which represents the smart contract implemented by the developer. Chaincode Process - Roles and Responsibilities and Components Breakdown Note The diagram provides a breakdown of the components with a particular reference to the chaincode shim written in Golang (i.e. fabric-chaincode-go ). These components can also be found in other implementations of the shim with minor differences. The main function of the chaincode process are: Setup and Coordination : this function is performed by the shim package which acts as main driver for the chaincode process. GRPC Communication : this function refers to the low-level interaction, connection setup, and management of the bidirectional stream with the peer. The components responsible for this function are: PeerChaincodeStream , ClientStream , RegisterClient , Server and ChaincodeServer . Protocol Execution : this function covers the message exchange with the peer, the management of the message receiving loop, the processing of messages, and the management of go-routines for asynchronous transaction simulation execution. The Handler is the component that does the heavy-lifting here, with support from the coordination logic implemented in the shim.Start(Chaincode) method. Interfacing : this function covers the interaction with the smart contract hosted in the chaincode process. The ChaincodeStubInteface defines the services exposed to the smart contract. These are implemented in the ChaincodeStub component, which acts as a liason between the smart contract the handler. The stub is also responsible for providing implementations of iterators for various types of range queries, which are access through the following interfaces: CommonQueryIteratorInterface , StateQueryIteratorInterface , and HistoryQueryIteratorInterface . Configuration : groups all the capabilities for customising and configuring the execution of the chaincode process. In particular, it provides information about the peer and the security settings for the communication via the Config component. Contract Business Logic : this function is exposed to the chaincode process via the Chaincode interface, which is implemented by the smart contract. The smart contract is the only component that is external to the shim. In the next section, we will be detailing the functions and the implementation of each of these components.","title":"Overview"},{"location":"shim-architecture/#fabric-chaincode-shim-architecture","text":"The figure below provides breakdown of the components that make up the chaincode process together with the role and responsibilities that each of the components have. It is worth noting, that while the shim is a specific component of the chaincode process, unless differently specified the shim is also used to refer to the set of components that make up the chaincode process except for the implementation of the chaincode interface, which represents the smart contract implemented by the developer. Chaincode Process - Roles and Responsibilities and Components Breakdown Note The diagram provides a breakdown of the components with a particular reference to the chaincode shim written in Golang (i.e. fabric-chaincode-go ). These components can also be found in other implementations of the shim with minor differences. The main function of the chaincode process are: Setup and Coordination : this function is performed by the shim package which acts as main driver for the chaincode process. GRPC Communication : this function refers to the low-level interaction, connection setup, and management of the bidirectional stream with the peer. The components responsible for this function are: PeerChaincodeStream , ClientStream , RegisterClient , Server and ChaincodeServer . Protocol Execution : this function covers the message exchange with the peer, the management of the message receiving loop, the processing of messages, and the management of go-routines for asynchronous transaction simulation execution. The Handler is the component that does the heavy-lifting here, with support from the coordination logic implemented in the shim.Start(Chaincode) method. Interfacing : this function covers the interaction with the smart contract hosted in the chaincode process. The ChaincodeStubInteface defines the services exposed to the smart contract. These are implemented in the ChaincodeStub component, which acts as a liason between the smart contract the handler. The stub is also responsible for providing implementations of iterators for various types of range queries, which are access through the following interfaces: CommonQueryIteratorInterface , StateQueryIteratorInterface , and HistoryQueryIteratorInterface . Configuration : groups all the capabilities for customising and configuring the execution of the chaincode process. In particular, it provides information about the peer and the security settings for the communication via the Config component. Contract Business Logic : this function is exposed to the chaincode process via the Chaincode interface, which is implemented by the smart contract. The smart contract is the only component that is external to the shim. In the next section, we will be detailing the functions and the implementation of each of these components.","title":"Fabric Chaincode Shim Architecture"},{"location":"shim-architecture/execution-patterns/","text":"Chaincode Execution Patterns The fabric shim supports two execution modalities, which control the connection behaviour of the chaincode with the peer: Chaincode as Client : this is the default modality and the only one used in Hyperledger Fabric v1.4. This is the execution mode that has been discussed in this documentation and features the chaincode process being a client that initiates the connection to the peer. Chaincode as Server : this modality, not in use yet, is a preview of a future capability and features the chaincode running as a standalone server accepting connection from the peers. Even though the Chaincode as Server is not currently used it is already available in the implementation of the fabric-chaincode-go shim. Besides the differences in the initial setup of the process, this modality will eventually invoke the chatWithPeer(string, ClientStream, Chaincode) function as happens for the Chaincode as Client execution modality, that is driven by the shim. In this section we will only focus in the initial setup differences. More details about this execution modality can be found in the Hyperledger Fabric Documentation . Chaincode as Server Setup Starting from v2.0 Hyperledger Fabric supports chaincode deployment outside of Fabric, thus enabling users to manage a chaincode runtime independently from the peer. This capability becomes particularly useful in cloud deployments such as Kubernetes, where the chaicode can be managed as a service with an independent life-cycle from the fabric network. In this scenario it is not necessary to build and launch the chaincode for every peer. To support the chaincode as an external service, it is necessary: configure the peer with an external builder and launcher; and initialise and run the chaincode shim as a server process. The implementation of this modality for the chaincode shim, can be found in the following files: shim/chaincodeserver.go : implementation of the protobuf service that exposes the Chaincode interface as GRPC service; and shim/internal/server.go : implementation of a simple GRPC server that is used to register the ChaincodeServer service, accept connections from the peers, and relay the control to the configured Chaincode . To initialise the chaincode process in this modality, we wont be using the shim.Start(Chaincode) method as a driver for the chaincode process but we will be calling the ChaincodeServer.Start(Chaincode) method on a newly created ChaincodeServer struct. // repository: https://github.com/hyperledger/fabric-protos // file: peer/chaincode_shim.proto service Chaincode { rpc Connect ( stream ChincodeMessage ) returns ( stream ChaincodeMessage ) } The listing above shows the definition of the interface that exposes the Chaincode as a GRPC service. The behaviour is very similar to the Chaincode as Client execution pattern but simply reversed. The interface only declares one method that opens a bidirectional stream with the peer. The implementation of the service bindings for Go can be found in the fabric-protos-go repository. The listing below provides a summarised view of the ChaincodeServer implementation with a focus on the key method that setup the chaincode process as a server. type ChaincodeServer struct { CCID string Address string CC Chaincode TLSPRops TLSProperties KaOpts * keepalive . ServerParameters } func ( cs * ChaincodeServer ) Connect ( stream pb . Chaincode_ConnectServer ) error { return chatWithPeer ( cs . CCID , stream , cs . CC ) } func ( cs * ChaincodeServer ) Start () error { ... server , err := internal . newServer ( cs . Address , tlsCfg , cs . KaOpts ) ... pb . RegisterChaincodeServer ( server . Server , cs ) return server . Start () } As shown in the listing the method that is bound to the Connect function exposed by the GRPC service simply calls chatWithPeer(string, ClientStream, Chaincode) by passing the bidirectional stream just established for the incoming connection and the Chaincode implementation that is configured with the server. Once the method is invoked, the control for that connection is passed to message receiving loop that has been previously discussed. Below is a simple example of how to initialise the process as a server and configure it with a Chaincode implementation. type SimpleChaincode struct {} func ( ssc * SimpleChaincode ) Init ( stub shim . ChaincodeInterface ) * pb . Response { ... . } func ( ssc * SimpleChaincode ) Invoke ( stub shim . ChaincodeInterface ) * pb . Response { ... . } func main () { ccid := \"simplechaincode:1.0\" server := & shim . ChaincodeServer { CCID : ccid , Address : \"localhost:9999\" , CC : new ( SimpleChaincode ), TLSProp : shim . TLSProperties { Disabled : true }, } err := server . Start () if err != nil { fmt . Printf ( \"Error starting the simple chaincode server: %s\" , err ) } } For the configuration of the connection properties and the security see the section Securing the Chaincode Process .","title":"Chaincode Execution Patterns"},{"location":"shim-architecture/execution-patterns/#chaincode-execution-patterns","text":"The fabric shim supports two execution modalities, which control the connection behaviour of the chaincode with the peer: Chaincode as Client : this is the default modality and the only one used in Hyperledger Fabric v1.4. This is the execution mode that has been discussed in this documentation and features the chaincode process being a client that initiates the connection to the peer. Chaincode as Server : this modality, not in use yet, is a preview of a future capability and features the chaincode running as a standalone server accepting connection from the peers. Even though the Chaincode as Server is not currently used it is already available in the implementation of the fabric-chaincode-go shim. Besides the differences in the initial setup of the process, this modality will eventually invoke the chatWithPeer(string, ClientStream, Chaincode) function as happens for the Chaincode as Client execution modality, that is driven by the shim. In this section we will only focus in the initial setup differences. More details about this execution modality can be found in the Hyperledger Fabric Documentation .","title":"Chaincode Execution Patterns"},{"location":"shim-architecture/execution-patterns/#chaincode-as-server-setup","text":"Starting from v2.0 Hyperledger Fabric supports chaincode deployment outside of Fabric, thus enabling users to manage a chaincode runtime independently from the peer. This capability becomes particularly useful in cloud deployments such as Kubernetes, where the chaicode can be managed as a service with an independent life-cycle from the fabric network. In this scenario it is not necessary to build and launch the chaincode for every peer. To support the chaincode as an external service, it is necessary: configure the peer with an external builder and launcher; and initialise and run the chaincode shim as a server process. The implementation of this modality for the chaincode shim, can be found in the following files: shim/chaincodeserver.go : implementation of the protobuf service that exposes the Chaincode interface as GRPC service; and shim/internal/server.go : implementation of a simple GRPC server that is used to register the ChaincodeServer service, accept connections from the peers, and relay the control to the configured Chaincode . To initialise the chaincode process in this modality, we wont be using the shim.Start(Chaincode) method as a driver for the chaincode process but we will be calling the ChaincodeServer.Start(Chaincode) method on a newly created ChaincodeServer struct. // repository: https://github.com/hyperledger/fabric-protos // file: peer/chaincode_shim.proto service Chaincode { rpc Connect ( stream ChincodeMessage ) returns ( stream ChaincodeMessage ) } The listing above shows the definition of the interface that exposes the Chaincode as a GRPC service. The behaviour is very similar to the Chaincode as Client execution pattern but simply reversed. The interface only declares one method that opens a bidirectional stream with the peer. The implementation of the service bindings for Go can be found in the fabric-protos-go repository. The listing below provides a summarised view of the ChaincodeServer implementation with a focus on the key method that setup the chaincode process as a server. type ChaincodeServer struct { CCID string Address string CC Chaincode TLSPRops TLSProperties KaOpts * keepalive . ServerParameters } func ( cs * ChaincodeServer ) Connect ( stream pb . Chaincode_ConnectServer ) error { return chatWithPeer ( cs . CCID , stream , cs . CC ) } func ( cs * ChaincodeServer ) Start () error { ... server , err := internal . newServer ( cs . Address , tlsCfg , cs . KaOpts ) ... pb . RegisterChaincodeServer ( server . Server , cs ) return server . Start () } As shown in the listing the method that is bound to the Connect function exposed by the GRPC service simply calls chatWithPeer(string, ClientStream, Chaincode) by passing the bidirectional stream just established for the incoming connection and the Chaincode implementation that is configured with the server. Once the method is invoked, the control for that connection is passed to message receiving loop that has been previously discussed. Below is a simple example of how to initialise the process as a server and configure it with a Chaincode implementation. type SimpleChaincode struct {} func ( ssc * SimpleChaincode ) Init ( stub shim . ChaincodeInterface ) * pb . Response { ... . } func ( ssc * SimpleChaincode ) Invoke ( stub shim . ChaincodeInterface ) * pb . Response { ... . } func main () { ccid := \"simplechaincode:1.0\" server := & shim . ChaincodeServer { CCID : ccid , Address : \"localhost:9999\" , CC : new ( SimpleChaincode ), TLSProp : shim . TLSProperties { Disabled : true }, } err := server . Start () if err != nil { fmt . Printf ( \"Error starting the simple chaincode server: %s\" , err ) } } For the configuration of the connection properties and the security see the section Securing the Chaincode Process .","title":"Chaincode as Server Setup"},{"location":"shim-architecture/security/","text":"Securing the Chaincode Process The security of the communication with the peer is managed through a set of environment variables passed to the chaincode process at startup. These are: CODE_CHAINCODE_ID_NAME : it provides the chaincode process with its identification details that are used to when it register itself with the peer. This parameter is essential for the protocol to work and not only a security switch. CORE_PEER_TLS_ENABLED : this is the main switch to enable TLS communication with the peer. It can be set to true or false. If false all the other TLS parameter are ignored. CORE_PEER_TLS_ROOT_CERT_FILE : this is file containing the CA root that signed the TLS certificate that will be presented by the peer. CORE_TLS_CLIENT_KEY_FILE | CORE_TLS_CLIENT_KEY_PATH : location of the of the private key of the client certificate used by the chaincode process to connect. First file is checked, if not found path is looked up. CORE_TLS_CLIENT_CERT_FILE | CORE_TLS_CLIENT_CERT_PATH : location of the of the client certificate used by the chaincode process to connect. First file is checked, if not found path is looked up. In addition to these environment variables the --peer.address command line flag is used to pass the address (host and port) that exposes in the peer the GRPC service for chaincode support. This is the endpoint that the chaincode process will connect to. These configuration settings are processed and managed by the Config component, whose implementation is located in the config.go file. The listing below shows a summarised version of the file and highlights its key functions. import ( \"crypto/tls\" ... h \"google.golang.org/grpc/keepalive\" ) type Config struct { ChaincodeName string , TLS * tls . Config , KaOpts keepalive . ClientParameters } func LoadConfig () ( * Config , error ) { ... . } func LoadTLSConfig ( isserver bool , key , cert , root [] byte ) ( * tls . Config , error ) { ... . } The function LoadConfig() parses the environment variables and generates the overall configuration for the shim. The function LoadTLSConfig(...) is called by the LoadConfig() function if TLS is enabled and configures the TLS section of the shim configuration. TLS Setup The configuration of the TLS (v1.2) capabilities is sensitive to the chaincode executino patterns, since different certificates need to be provided if the chaincode runs as a client to the peer or as a standalone server. Chaincode as Client This is currently the default and it is enforced by hard-coding the value of the isserver flag to false . In this modality, the parameters passed to the LoadTLSConfig(...) are interpreted as follows: the root certificate passed to the LoadTLSConfig(...) function is used to construct the pool of root certificates (i.e. tlsConfig.RoorCAs ) that the GRPC client should trust to validate the server (i.e. the peer); and the key and cert pair represent the client certificate that the chaincode process will present to the peer to establish the connection. The resulting tls.Config instance is passed to the connection setup function which establishes the GRPC connection with the per and creates a client for the chaincode support service: func NewClientConn ( address string , tlsConf * tls . Config , kaOpts keepalive . ClientParameters ) ( * grpc . ClientConn , error ) ( ... } Chaincode as Server This mode is not currently used in version 1.4, but it is a preview of future version of the implementation. In this modality the configuration parameters for the TLS setup are pulled from the ChaincodeServer.TLSProps struct that defines the configuration of the server: the root certificate cannot be null and contributes to the creation of the pool of certificates that are checked by the server to validate the client certificates provided by the connecting peers (i.e. tlsConfig.ClientCAs ). These are required and must be valid (i.e. tlsConfig.ClientAut=tls.RequireAndVerifyClient ); and the key and cert pair provides access to server certificate that will be presented to the incoming connections to identify the chaincode process. The resulting tls.Config instance is passed to the server setup function that starts the chaincode server: func NewServer ( address string , tlsConf * tls . Config , srvKaOpts keepalive . ServerParameters ) ( * Server , error ) { ... } This function is located in the file server.go .","title":"Securing the Chaincode Process"},{"location":"shim-architecture/security/#securing-the-chaincode-process","text":"The security of the communication with the peer is managed through a set of environment variables passed to the chaincode process at startup. These are: CODE_CHAINCODE_ID_NAME : it provides the chaincode process with its identification details that are used to when it register itself with the peer. This parameter is essential for the protocol to work and not only a security switch. CORE_PEER_TLS_ENABLED : this is the main switch to enable TLS communication with the peer. It can be set to true or false. If false all the other TLS parameter are ignored. CORE_PEER_TLS_ROOT_CERT_FILE : this is file containing the CA root that signed the TLS certificate that will be presented by the peer. CORE_TLS_CLIENT_KEY_FILE | CORE_TLS_CLIENT_KEY_PATH : location of the of the private key of the client certificate used by the chaincode process to connect. First file is checked, if not found path is looked up. CORE_TLS_CLIENT_CERT_FILE | CORE_TLS_CLIENT_CERT_PATH : location of the of the client certificate used by the chaincode process to connect. First file is checked, if not found path is looked up. In addition to these environment variables the --peer.address command line flag is used to pass the address (host and port) that exposes in the peer the GRPC service for chaincode support. This is the endpoint that the chaincode process will connect to. These configuration settings are processed and managed by the Config component, whose implementation is located in the config.go file. The listing below shows a summarised version of the file and highlights its key functions. import ( \"crypto/tls\" ... h \"google.golang.org/grpc/keepalive\" ) type Config struct { ChaincodeName string , TLS * tls . Config , KaOpts keepalive . ClientParameters } func LoadConfig () ( * Config , error ) { ... . } func LoadTLSConfig ( isserver bool , key , cert , root [] byte ) ( * tls . Config , error ) { ... . } The function LoadConfig() parses the environment variables and generates the overall configuration for the shim. The function LoadTLSConfig(...) is called by the LoadConfig() function if TLS is enabled and configures the TLS section of the shim configuration.","title":"Securing the Chaincode Process"},{"location":"shim-architecture/security/#tls-setup","text":"The configuration of the TLS (v1.2) capabilities is sensitive to the chaincode executino patterns, since different certificates need to be provided if the chaincode runs as a client to the peer or as a standalone server.","title":"TLS Setup"},{"location":"shim-architecture/security/#chaincode-as-client","text":"This is currently the default and it is enforced by hard-coding the value of the isserver flag to false . In this modality, the parameters passed to the LoadTLSConfig(...) are interpreted as follows: the root certificate passed to the LoadTLSConfig(...) function is used to construct the pool of root certificates (i.e. tlsConfig.RoorCAs ) that the GRPC client should trust to validate the server (i.e. the peer); and the key and cert pair represent the client certificate that the chaincode process will present to the peer to establish the connection. The resulting tls.Config instance is passed to the connection setup function which establishes the GRPC connection with the per and creates a client for the chaincode support service: func NewClientConn ( address string , tlsConf * tls . Config , kaOpts keepalive . ClientParameters ) ( * grpc . ClientConn , error ) ( ... }","title":"Chaincode as Client"},{"location":"shim-architecture/security/#chaincode-as-server","text":"This mode is not currently used in version 1.4, but it is a preview of future version of the implementation. In this modality the configuration parameters for the TLS setup are pulled from the ChaincodeServer.TLSProps struct that defines the configuration of the server: the root certificate cannot be null and contributes to the creation of the pool of certificates that are checked by the server to validate the client certificates provided by the connecting peers (i.e. tlsConfig.ClientCAs ). These are required and must be valid (i.e. tlsConfig.ClientAut=tls.RequireAndVerifyClient ); and the key and cert pair provides access to server certificate that will be presented to the incoming connections to identify the chaincode process. The resulting tls.Config instance is passed to the server setup function that starts the chaincode server: func NewServer ( address string , tlsConf * tls . Config , srvKaOpts keepalive . ServerParameters ) ( * Server , error ) { ... } This function is located in the file server.go .","title":"Chaincode as Server"},{"location":"shim-architecture/components/chaincode-stub-interface/","text":"ChaincodeStubInterface The ChaincodeStubInterface represents the interface to the transaction execution context for the smart contract. Implementations of this interface are responsible for providing the chaincode implementation with details about the execution context in which a transaction is invoked (i.e. channel id and other metadata) and for interacting with the peer for any talk back (i.e. ledger queries and cross-chaincode invocations). Characterisation The ChaincodeStubInteface is defined in the file interfaces.go . The capabilities exposes are a combination of: methods that resolve locally; and methods that involve the interaction with the peer. The inteface exposes a synchronous behaviour. This means that for all those methods that involve an interaction with the peer the control will be held back until the peer has responded to the request and the corresponding ChaincodeMessage has been processed by the handler to unpack the result and create any supporting component needed. Capabilities and Message Mapping The table below provides an overview of all the methods exposed by the interface with a mapping to the corresponding ChaincodeMessage type sent, if any. It is respomsibility of the implementation of this interface to honor this contract and send the specified message for a correct execution of the interaction protocol. Method Is Local Comments Chaincode Message Type GetArgs Yes Returns the arguments of the transaction invocation (function and args) as an array of bytes. N/A GetStringArgs Yes Returns the arguments of the transaction invocation (function and args) as an array of strings. N/A GetFunctionAndParameters Yes Returns the arguments of the transaction invocation (function and args). N/A GetArgsSlice Yes Returns the arguments of the transaction invocation (function and args) as a single byte array. N/A GetTxID Yes Returns the unique identifier of the transaction as a string. N/A GetChannelID Yes Returns the unique identifier of the channel as a string. N/A InvokeChaincode No Invokes another chaincode installed on the same peer. INVOKE_CHAINCODE GetState No Retrieves the value of a key. GET_STATE PutState No Sets the value of a key. PUT_STATE DelState No Removes the specified key from the world state. DEL_STATE SetStateValidationParameter No Set the endorsement policy for the specified key (feature: state-based endorsements). PUT_STATE_METADATA GetStateValidationParameter No Retrieves the endorsement policy for the specified key (feature: state-based endorsements). GET_STATE_METADATA GetStateByRange No Returns a range iterator over the keys within the identifier range. GET_STATE_BY_RANGE GetStateByRangeWithPagination No Returns a range iterator over the keys within the identifier range (paginated version). GET_STATE_BY_RANGE GetStateByPartialCompositeKey No Returns a range iterator over the set of keys that match the specified partial key. GET_STATE_BY_RANGE GetStateByPartialCompositeKeyWithPagination No Returns a range iterator over the keys matching the specified partial key (paginated version). GET_STATE_BY_RANGE CreateCompositeKey Yes Creates a composite key with the supplied arguments. N/A SplitCompositeKey Yes Splits the specified composite key into its components (objectType and attributes). N/A GetQueryResult No Performs a rich query against the state database and returns a range iterator over the result. GET_QUERY_RESULT GetQueryResultWithPagination No As above but with pagination. GET_QUERY_RESULT GetHistoryForKey No Returns a range iterator over all the historical changes associated to a specified key. GET_HISTORY_FOR_KEY GetPrivateData No Returns the value of the specified key in the specified collection. GET_STATE GetPrivateDataHash No Returns the hash of the value of the specified key in the specified collection. GET_PRIVATE_DATA_HASH PutPrivateData No Sets the value of the specified key in the specified collection (when the transaction will be committed). PUT_STATE DelPrivateData No Removes the value of a specified key in the specified collection (when the transaction will be committed). DEL_STATE SetPrivateDataStateValidationParameter No Set the endorsement policy for the specified key in the specified collection (feature: state-based endorsements). PUT_STATE_METADATA GetPrivateDataStateValidationParameter No Retrieves the endorsement policy for the specified key in the specified collection (feature: state-based endorsements). GET_STATE_METADATA GetPrivateDataByRange No Returns a range iterator over all the keys in the specified collection within the specified start and end key. GET_STATE_BY_RANGE GetPrivateDataByPartialCompositeKey No Returns a range iterator over all the keys in the specified collection matching the specified partial key. GET_STATE_BY_RANGE GetPrivateDataQueryResult No Performs a rich query against the specified collection and returns a range iterator over the keys matching the given query. GET_QUERY_RESULT GetCreator Yes Returns the array of bytes representing the X.509 identity of the agent/user submitting the transaction. N/A GetBinding Yes Returns the transaction binding. N/A GetTransient Yes Returns metadata associated to the transaction, which can be used for instance to implement application confidentiality (e.g. crypto material). N/A GetDecorations Yes Returns metadata added to the transaction by decorators of the peer. These may mutate the chaincode input as a result of their function. N/A GetSignedProposal Yes Returns the signed proposal, which contains all the data elements of the transactio proposal. N/A GetTxTimestamp Yes Returns the transaction timestamp of what the transaction was created. N/A SetEvent Yes Sets an event associated to the transaction. N/A","title":"ChaincodeStubInterface"},{"location":"shim-architecture/components/chaincode-stub-interface/#chaincodestubinterface","text":"The ChaincodeStubInterface represents the interface to the transaction execution context for the smart contract. Implementations of this interface are responsible for providing the chaincode implementation with details about the execution context in which a transaction is invoked (i.e. channel id and other metadata) and for interacting with the peer for any talk back (i.e. ledger queries and cross-chaincode invocations).","title":"ChaincodeStubInterface"},{"location":"shim-architecture/components/chaincode-stub-interface/#characterisation","text":"The ChaincodeStubInteface is defined in the file interfaces.go . The capabilities exposes are a combination of: methods that resolve locally; and methods that involve the interaction with the peer. The inteface exposes a synchronous behaviour. This means that for all those methods that involve an interaction with the peer the control will be held back until the peer has responded to the request and the corresponding ChaincodeMessage has been processed by the handler to unpack the result and create any supporting component needed.","title":"Characterisation"},{"location":"shim-architecture/components/chaincode-stub-interface/#capabilities-and-message-mapping","text":"The table below provides an overview of all the methods exposed by the interface with a mapping to the corresponding ChaincodeMessage type sent, if any. It is respomsibility of the implementation of this interface to honor this contract and send the specified message for a correct execution of the interaction protocol. Method Is Local Comments Chaincode Message Type GetArgs Yes Returns the arguments of the transaction invocation (function and args) as an array of bytes. N/A GetStringArgs Yes Returns the arguments of the transaction invocation (function and args) as an array of strings. N/A GetFunctionAndParameters Yes Returns the arguments of the transaction invocation (function and args). N/A GetArgsSlice Yes Returns the arguments of the transaction invocation (function and args) as a single byte array. N/A GetTxID Yes Returns the unique identifier of the transaction as a string. N/A GetChannelID Yes Returns the unique identifier of the channel as a string. N/A InvokeChaincode No Invokes another chaincode installed on the same peer. INVOKE_CHAINCODE GetState No Retrieves the value of a key. GET_STATE PutState No Sets the value of a key. PUT_STATE DelState No Removes the specified key from the world state. DEL_STATE SetStateValidationParameter No Set the endorsement policy for the specified key (feature: state-based endorsements). PUT_STATE_METADATA GetStateValidationParameter No Retrieves the endorsement policy for the specified key (feature: state-based endorsements). GET_STATE_METADATA GetStateByRange No Returns a range iterator over the keys within the identifier range. GET_STATE_BY_RANGE GetStateByRangeWithPagination No Returns a range iterator over the keys within the identifier range (paginated version). GET_STATE_BY_RANGE GetStateByPartialCompositeKey No Returns a range iterator over the set of keys that match the specified partial key. GET_STATE_BY_RANGE GetStateByPartialCompositeKeyWithPagination No Returns a range iterator over the keys matching the specified partial key (paginated version). GET_STATE_BY_RANGE CreateCompositeKey Yes Creates a composite key with the supplied arguments. N/A SplitCompositeKey Yes Splits the specified composite key into its components (objectType and attributes). N/A GetQueryResult No Performs a rich query against the state database and returns a range iterator over the result. GET_QUERY_RESULT GetQueryResultWithPagination No As above but with pagination. GET_QUERY_RESULT GetHistoryForKey No Returns a range iterator over all the historical changes associated to a specified key. GET_HISTORY_FOR_KEY GetPrivateData No Returns the value of the specified key in the specified collection. GET_STATE GetPrivateDataHash No Returns the hash of the value of the specified key in the specified collection. GET_PRIVATE_DATA_HASH PutPrivateData No Sets the value of the specified key in the specified collection (when the transaction will be committed). PUT_STATE DelPrivateData No Removes the value of a specified key in the specified collection (when the transaction will be committed). DEL_STATE SetPrivateDataStateValidationParameter No Set the endorsement policy for the specified key in the specified collection (feature: state-based endorsements). PUT_STATE_METADATA GetPrivateDataStateValidationParameter No Retrieves the endorsement policy for the specified key in the specified collection (feature: state-based endorsements). GET_STATE_METADATA GetPrivateDataByRange No Returns a range iterator over all the keys in the specified collection within the specified start and end key. GET_STATE_BY_RANGE GetPrivateDataByPartialCompositeKey No Returns a range iterator over all the keys in the specified collection matching the specified partial key. GET_STATE_BY_RANGE GetPrivateDataQueryResult No Performs a rich query against the specified collection and returns a range iterator over the keys matching the given query. GET_QUERY_RESULT GetCreator Yes Returns the array of bytes representing the X.509 identity of the agent/user submitting the transaction. N/A GetBinding Yes Returns the transaction binding. N/A GetTransient Yes Returns metadata associated to the transaction, which can be used for instance to implement application confidentiality (e.g. crypto material). N/A GetDecorations Yes Returns metadata added to the transaction by decorators of the peer. These may mutate the chaincode input as a result of their function. N/A GetSignedProposal Yes Returns the signed proposal, which contains all the data elements of the transactio proposal. N/A GetTxTimestamp Yes Returns the transaction timestamp of what the transaction was created. N/A SetEvent Yes Sets an event associated to the transaction. N/A","title":"Capabilities and Message Mapping"},{"location":"shim-architecture/components/chaincode-stub/","text":"ChaincodeStub The ChaincodeStub is the default implementation of the ChaincodeStubInterface and it is the component that connects the Chaincode to the hosting environment by providing the services exposed by the interface. The responsibilities of the ChaincodeStub are the following: providing access to the transaction context reconstructed from the INIT and TRANSACTION messages sent by the peer; preparing the data for the Handler for chaincode requests back to the peer; and managing the iterators that are returned when the smart contract makes complex or range queries. The chaincode stub structure and methods are defined in the file stub.go . Initialisation A new chaincode stub is created by the handler for each transaction invocation. Therefore, the stub has only memory of the execution context of the current transation. Upon the reception of an INIT or TRANSACTION message, the handler unpacks the payload and invokes the following function to create the stub: func newChaincodeStub ( handler * Handler , channelID , txid string , input * pb . ChaincodeInput , signedProposal * pb . SignedProposal ) ( * ChaincodeStub , error ) { ... } The method returns a pointer to the ChaincodeStub structure that is shown in the listing below: type ChaincodeStub struct { TxID string ChannelID string chaincodeEvent * pb . ChaincodeEvent args [][] byte handler * Handler signedProposal * pb . SignedProposal proposal * pb . Proposal validationParameterMetakey string // Additional fields extracted from the signedProposal creator [] byte transient map [ string ][] byte binding [] byte decorations map [ string ][] byte } The fields TxID , ChannelID , args , signedProposal , proposal , creator , transient , binding , decorations , and validationParameterMetaKey are extracted by the message that triggered the execution of the transaction, while the chaincodeEvent is a place-holder to maintain the last event triggered by the smart contract during the transaction invocation. The initialisation of the stub entails the validation of the signed proposal (if not null) to ensure that the proposal has a correct header and to compute the binding for the chaincode message. Normal chaincode invocation have a non-null signed proposal, while the system chaincodes can be initialised with a null proposal. Interfacing The ChaincodeStub maintains a pointer to the Handler that has created it and uses such reference to implement all the services that require talking back to the peer. Most of the methods of the stubs are simple pass-through to the handler, which manages the interaction with the peer and packaging of arguments in corresponding chaincode messages. Here is an example of the complexity of the methods implemented to retrieve the both the public and private state for a channel: func ( s * ChaincodeStub ) GetState ( key string ) ([] byte , error ) { collection := \"\" return s . handler . handleGetState ( collection , key , s . ChannelID , s . TxID ) } func ( s * ChaincodeStub ) GetPrivateData ( collection string , key string ) ([] byte , error ) { if collection == \"\" { return nil , fmt . Errorf ( \"collection must not be an empty string\" ) } return s . handler . handleGetState ( collection , key , s . ChannelID , s . TxID ) } With a few exceptions, the majority of the methods of the stub are this simple. As shown in the listing one of the roles of the stub is rely a set of core methods of the handler to provide a rich interface to the smart contract. In this case, the listing shows how the retrieval of both public aivate data relies on the same methods of the handler, which is invoked with different parameters. A capability that sees the ChaincodeStub playing an essential role is are range and history queries . For these functions exposed by the ChaincodeStubInterface the stub implements and manage the iterators that are retrieved by the corresponding methods and coordinates their interaction with the handler to fetch new batches of data once the local cache has been consumed. The section Range Queries and Iterators will discuss these capabilities in detail.","title":"ChaincodeStub"},{"location":"shim-architecture/components/chaincode-stub/#chaincodestub","text":"The ChaincodeStub is the default implementation of the ChaincodeStubInterface and it is the component that connects the Chaincode to the hosting environment by providing the services exposed by the interface. The responsibilities of the ChaincodeStub are the following: providing access to the transaction context reconstructed from the INIT and TRANSACTION messages sent by the peer; preparing the data for the Handler for chaincode requests back to the peer; and managing the iterators that are returned when the smart contract makes complex or range queries. The chaincode stub structure and methods are defined in the file stub.go .","title":"ChaincodeStub"},{"location":"shim-architecture/components/chaincode-stub/#initialisation","text":"A new chaincode stub is created by the handler for each transaction invocation. Therefore, the stub has only memory of the execution context of the current transation. Upon the reception of an INIT or TRANSACTION message, the handler unpacks the payload and invokes the following function to create the stub: func newChaincodeStub ( handler * Handler , channelID , txid string , input * pb . ChaincodeInput , signedProposal * pb . SignedProposal ) ( * ChaincodeStub , error ) { ... } The method returns a pointer to the ChaincodeStub structure that is shown in the listing below: type ChaincodeStub struct { TxID string ChannelID string chaincodeEvent * pb . ChaincodeEvent args [][] byte handler * Handler signedProposal * pb . SignedProposal proposal * pb . Proposal validationParameterMetakey string // Additional fields extracted from the signedProposal creator [] byte transient map [ string ][] byte binding [] byte decorations map [ string ][] byte } The fields TxID , ChannelID , args , signedProposal , proposal , creator , transient , binding , decorations , and validationParameterMetaKey are extracted by the message that triggered the execution of the transaction, while the chaincodeEvent is a place-holder to maintain the last event triggered by the smart contract during the transaction invocation. The initialisation of the stub entails the validation of the signed proposal (if not null) to ensure that the proposal has a correct header and to compute the binding for the chaincode message. Normal chaincode invocation have a non-null signed proposal, while the system chaincodes can be initialised with a null proposal.","title":"Initialisation"},{"location":"shim-architecture/components/chaincode-stub/#interfacing","text":"The ChaincodeStub maintains a pointer to the Handler that has created it and uses such reference to implement all the services that require talking back to the peer. Most of the methods of the stubs are simple pass-through to the handler, which manages the interaction with the peer and packaging of arguments in corresponding chaincode messages. Here is an example of the complexity of the methods implemented to retrieve the both the public and private state for a channel: func ( s * ChaincodeStub ) GetState ( key string ) ([] byte , error ) { collection := \"\" return s . handler . handleGetState ( collection , key , s . ChannelID , s . TxID ) } func ( s * ChaincodeStub ) GetPrivateData ( collection string , key string ) ([] byte , error ) { if collection == \"\" { return nil , fmt . Errorf ( \"collection must not be an empty string\" ) } return s . handler . handleGetState ( collection , key , s . ChannelID , s . TxID ) } With a few exceptions, the majority of the methods of the stub are this simple. As shown in the listing one of the roles of the stub is rely a set of core methods of the handler to provide a rich interface to the smart contract. In this case, the listing shows how the retrieval of both public aivate data relies on the same methods of the handler, which is invoked with different parameters. A capability that sees the ChaincodeStub playing an essential role is are range and history queries . For these functions exposed by the ChaincodeStubInterface the stub implements and manage the iterators that are retrieved by the corresponding methods and coordinates their interaction with the handler to fetch new batches of data once the local cache has been consumed. The section Range Queries and Iterators will discuss these capabilities in detail.","title":"Interfacing"},{"location":"shim-architecture/components/handler/","text":"Handler The chaincode handler is responsible for managing the entire communication protocol with the peer (from the initialisation of the communication to the end) and ultimately for invoking the Chaincode interface methods on the configured implementation. More specifically, the responsibilities of the handler are: ChaincodeMessage packing and unpacking; concurrency management to support multiple transaction execution at the same time; chaincode implementation life-cycle management (register, initialise, and execute); recreation of the transaction context required to invoke smart contract methods; and request forwarding from the chaincode implementation to the peer (i.e. ledger queries and cross-chaincode invocations). The handler is defined in the handler.go . Execution Model The handler exists a single instance in in the shim and it is implemented as a state machine that follows the life-cycle of the chaincode. The state evolution is shown in the figure below and it is driven by the messages received from the peer. Chaincode Handler State Machine There are three states that define the behaviour of the handler: created , established , and ready . The state of the handler determines the type of messages that it expects from the peer for a correct interaction protocol. Initialisation A new instance of the handler is created by shim during setup, via the newChaincodeHandler(stream PeerChaincodeStream, cc Chaincode) method. This method configures the handler with the Chaincode implementation, the bidirectional stream, and also initialises the internal data structure required by the handler to operate. The invocation of the method returns a pointer to the Handler struct that is shown in the listing below. Upon creation the handler is set to the created state. type Handler struct { // used to serialise the access to the stream // and synchronise concurrent writes serialLock sync . Mutex // bidirectional stream open with the peer configured // to exchange pb.ChaincodeMessage instances chatStream PeerChaincodeStream // chaincode implementation cc Chaincode // state of the handler state state // used to serialise updates to the responseChannels // map that keep tracks of the chaincode requests to // the peer that are currently in flight responseChannelsMutex sync . Muttex // keeps track of the chaincode requests to the peer // currently in flight. For each transaction there is // an expectation that at most one request at the time // will be active responseChannels map [ string ] chan pb . ChaincodeMessage } Functionalities The Handler struct is bound to methods that cater for four distinct capabilities. Sending and Receiving Messages serialSend(msg *pb.ChaincodeMessage) serialSendAsync(msg *pb.ChaincodeMessage, errc <- chan error) sendReceive(msg *pb.ChaincodeMessage, responseChan <- chan pb.ChaincodeMessage) Processing Messages from the Peer handleXXX(msg *pb.ChaincodeMessage) handleStubInteraction(..., *pb.ChaincodeMessage) Processing Request/Responses from the Stub handleXXX(....) - in this case the argument is not a pb.ChaincodeMessage createResponse(status int32, payload []byte) Managing Response Channels createResponseChannel(channelID string, txid string) deleteResponseChannel(channelID string, txid string)","title":"Handler"},{"location":"shim-architecture/components/handler/#handler","text":"The chaincode handler is responsible for managing the entire communication protocol with the peer (from the initialisation of the communication to the end) and ultimately for invoking the Chaincode interface methods on the configured implementation. More specifically, the responsibilities of the handler are: ChaincodeMessage packing and unpacking; concurrency management to support multiple transaction execution at the same time; chaincode implementation life-cycle management (register, initialise, and execute); recreation of the transaction context required to invoke smart contract methods; and request forwarding from the chaincode implementation to the peer (i.e. ledger queries and cross-chaincode invocations). The handler is defined in the handler.go .","title":"Handler"},{"location":"shim-architecture/components/handler/#execution-model","text":"The handler exists a single instance in in the shim and it is implemented as a state machine that follows the life-cycle of the chaincode. The state evolution is shown in the figure below and it is driven by the messages received from the peer. Chaincode Handler State Machine There are three states that define the behaviour of the handler: created , established , and ready . The state of the handler determines the type of messages that it expects from the peer for a correct interaction protocol.","title":"Execution Model"},{"location":"shim-architecture/components/handler/#initialisation","text":"A new instance of the handler is created by shim during setup, via the newChaincodeHandler(stream PeerChaincodeStream, cc Chaincode) method. This method configures the handler with the Chaincode implementation, the bidirectional stream, and also initialises the internal data structure required by the handler to operate. The invocation of the method returns a pointer to the Handler struct that is shown in the listing below. Upon creation the handler is set to the created state. type Handler struct { // used to serialise the access to the stream // and synchronise concurrent writes serialLock sync . Mutex // bidirectional stream open with the peer configured // to exchange pb.ChaincodeMessage instances chatStream PeerChaincodeStream // chaincode implementation cc Chaincode // state of the handler state state // used to serialise updates to the responseChannels // map that keep tracks of the chaincode requests to // the peer that are currently in flight responseChannelsMutex sync . Muttex // keeps track of the chaincode requests to the peer // currently in flight. For each transaction there is // an expectation that at most one request at the time // will be active responseChannels map [ string ] chan pb . ChaincodeMessage }","title":"Initialisation"},{"location":"shim-architecture/components/handler/#functionalities","text":"The Handler struct is bound to methods that cater for four distinct capabilities.","title":"Functionalities"},{"location":"shim-architecture/components/handler/#sending-and-receiving-messages","text":"serialSend(msg *pb.ChaincodeMessage) serialSendAsync(msg *pb.ChaincodeMessage, errc <- chan error) sendReceive(msg *pb.ChaincodeMessage, responseChan <- chan pb.ChaincodeMessage)","title":"Sending and Receiving Messages"},{"location":"shim-architecture/components/handler/#processing-messages-from-the-peer","text":"handleXXX(msg *pb.ChaincodeMessage) handleStubInteraction(..., *pb.ChaincodeMessage)","title":"Processing Messages from the Peer"},{"location":"shim-architecture/components/handler/#processing-requestresponses-from-the-stub","text":"handleXXX(....) - in this case the argument is not a pb.ChaincodeMessage createResponse(status int32, payload []byte)","title":"Processing Request/Responses from the Stub"},{"location":"shim-architecture/components/handler/#managing-response-channels","text":"createResponseChannel(channelID string, txid string) deleteResponseChannel(channelID string, txid string)","title":"Managing Response Channels"},{"location":"shim-architecture/components/other-components/","text":"Other Components The figure below provides an overview of the remaining components that make up the fabric shim highlighted in bold . The figure also shows the implementation of the response.go file that contains the deifinition of constants and helper functions that are used to create success and error responses by the chaincode developers. Shim Package The rest of the files cover: Configuration Management (i.e. config.go ): this will be discussed in more detail in the section Securing the Chaincode Process section. GRPC Client-server Communication (i.e. client.go and server.go ) Chaincode Execution as Server (i.e. chaincodeserver.go ): this will be discussed in more detail in the Chaincode Execution Patterns section.","title":"Other Components"},{"location":"shim-architecture/components/other-components/#other-components","text":"The figure below provides an overview of the remaining components that make up the fabric shim highlighted in bold . The figure also shows the implementation of the response.go file that contains the deifinition of constants and helper functions that are used to create success and error responses by the chaincode developers. Shim Package The rest of the files cover: Configuration Management (i.e. config.go ): this will be discussed in more detail in the section Securing the Chaincode Process section. GRPC Client-server Communication (i.e. client.go and server.go ) Chaincode Execution as Server (i.e. chaincodeserver.go ): this will be discussed in more detail in the Chaincode Execution Patterns section.","title":"Other Components"},{"location":"shim-architecture/components/shim/","text":"Shim The shim is responsible for starting and coordinating the interaction between the Chaincode implementation and the peer the process is connected to. The coordination and setup logic is implemented in the shim.go and the main method of the package is shim.Start(Chaincode) . The setup procedure is as follows: retrieval of the chaincode name in the format name:version from the environment; retrieval of the configuration (i.e. peer address and port, GRPC settings); initialisation of the bidirectional communication stream with the peer; and setup of the \"chat\" with the peer. The chat with the peer is implemented in the chatWithPeer(chaincodename string, stream PeerChaincodeStream, cc Chaincode) that is responsible for: initialising an instance of the chaincode handler with the bidirectional stream and the chaincode implementation sending the REGISTER message to register the chaincode process with the peer initialising the message and error channels initialising the message receving loop The shim package also provide another main entry point for the execution of chaincode. This is the StartInProc(chaincodename string, stream ClientStream, cc Chaincode) . This method is used for the execution of system chaincodes within the peer. The logic implemented here, eventually leads to calling chatWithPeer(...) . The only difference is the provision of the stream that connects the chaincode to the peer and the resolution of the chaincode name, which in this case is passed as an argument.","title":"Shim"},{"location":"shim-architecture/components/shim/#shim","text":"The shim is responsible for starting and coordinating the interaction between the Chaincode implementation and the peer the process is connected to. The coordination and setup logic is implemented in the shim.go and the main method of the package is shim.Start(Chaincode) . The setup procedure is as follows: retrieval of the chaincode name in the format name:version from the environment; retrieval of the configuration (i.e. peer address and port, GRPC settings); initialisation of the bidirectional communication stream with the peer; and setup of the \"chat\" with the peer. The chat with the peer is implemented in the chatWithPeer(chaincodename string, stream PeerChaincodeStream, cc Chaincode) that is responsible for: initialising an instance of the chaincode handler with the bidirectional stream and the chaincode implementation sending the REGISTER message to register the chaincode process with the peer initialising the message and error channels initialising the message receving loop The shim package also provide another main entry point for the execution of chaincode. This is the StartInProc(chaincodename string, stream ClientStream, cc Chaincode) . This method is used for the execution of system chaincodes within the peer. The logic implemented here, eventually leads to calling chatWithPeer(...) . The only difference is the provision of the stream that connects the chaincode to the peer and the resolution of the chaincode name, which in this case is passed as an argument.","title":"Shim"},{"location":"shim-architecture/interaction-flow/chaincode-events/","text":"Chaincode Events Overview Hyperledger Fabric supports the ability to raise events during the invocation of a chaincode transaction. Events are named objects that are recorded as part of the transaction execution and eventually bubbled up to the application clients connected to the same channel for their perusal once the transaction is committed. Note Events are ephemeral and are only raised at the transaction commitment time. If the application client is not connected to the channel at that point in time it will loose the opportunity to receive the event. For those applications that rely upon events for the correct operations of the off-chain functions, must implement event persistence within the smart contracts and provide access functions. Smart contract developers can call the following method to raise events from within the chaincode logic: func ( s * ChaincodeStubInterface ) SetEvent ( name string , payload [] byte ) error Only one event is alloiwed per transaction execution. In case of multiple invocations to this method, only the last one will be recorded in the transaction execution record, and therefore raised to the application clients, listening the channel events. Implementation Events are piggy-backed to the peer together wit the ChaincodeMessage of type COMPLETED (or ERROR ) at the end of the transaction simulation execution. The listing below represents the structure of the ChaincodeMessage and the associated field for the chaincode event. type ChaincodeMessage struct { Type ChaincodeMessage_Type Timestamp * timestamp . Timestamp Payload [] byte Txid string Proposal * SignedProposal // Event emitted by the chaincode. Used only with Init or Invoke. // This event is then stored with Block.NonHashData.TransactionResult ChaincodeEvent * ChaincodeEvent ChannelId string // Protobuf marshalling fields XXX_NoUnkeyedLiteral struct {} XXX_unrecognized [] byte XXX_sizecache int32 } type ChaincodeEvent struct { ChaincodeId string Txid string EventName string Payload [] byte // Protobuf marshalling fields XXX_NoUnkeyedLiteral struct {} XXX_unrecognized [] byte XXX_sizecache int32 } The last event se is locally cached in the stub and if present, then added to the chaincode message by the Handler when composing the response ChaincodeMessage at the end of the execution of the handleInit(...) and handleTransaction(...) methods. // file: shim/stub.go // func ( s * ChaincodeStub ) SetEvent ( name string , payload [] byte ) error { if name == \"\" { return errors . New ( \"event name cannot be empty string\" ) } s . chaincodeEvent = & pb . ChaincodeEvent { EventName : name , Payload : payload } } // file: shim/handler.go // func ( h * Handler ) handleInit ( msg * pb . ChaincodeMessage ) ( * pb . ChaincodeMessage , error ) { ... . stub , err := newChaincodeStub ( h , msg . ChannelId , msg . Txid , input , msg . Proposal ) ... . res := h . cc . Init ( stub ) resBytes , err := proto . Marshal ( & res ) ... return & pb . ChaincodeMessage { Type : pb . ChaincodeMessage_COMPLETED , Payload : resBytes , Txid : msg . Txid , ChaincodeEvent : stub . chaincodeEvent , ChannelId : stub . ChannelID }, nil } Note The listing shows the implementation of the handleInit(....) method. The implementation of the of the handleTransaction(....) method is identical, except for the invocation of the h.cc.Invoke(stub) method.","title":"Chaincode Events"},{"location":"shim-architecture/interaction-flow/chaincode-events/#chaincode-events","text":"","title":"Chaincode Events"},{"location":"shim-architecture/interaction-flow/chaincode-events/#overview","text":"Hyperledger Fabric supports the ability to raise events during the invocation of a chaincode transaction. Events are named objects that are recorded as part of the transaction execution and eventually bubbled up to the application clients connected to the same channel for their perusal once the transaction is committed. Note Events are ephemeral and are only raised at the transaction commitment time. If the application client is not connected to the channel at that point in time it will loose the opportunity to receive the event. For those applications that rely upon events for the correct operations of the off-chain functions, must implement event persistence within the smart contracts and provide access functions. Smart contract developers can call the following method to raise events from within the chaincode logic: func ( s * ChaincodeStubInterface ) SetEvent ( name string , payload [] byte ) error Only one event is alloiwed per transaction execution. In case of multiple invocations to this method, only the last one will be recorded in the transaction execution record, and therefore raised to the application clients, listening the channel events.","title":"Overview"},{"location":"shim-architecture/interaction-flow/chaincode-events/#implementation","text":"Events are piggy-backed to the peer together wit the ChaincodeMessage of type COMPLETED (or ERROR ) at the end of the transaction simulation execution. The listing below represents the structure of the ChaincodeMessage and the associated field for the chaincode event. type ChaincodeMessage struct { Type ChaincodeMessage_Type Timestamp * timestamp . Timestamp Payload [] byte Txid string Proposal * SignedProposal // Event emitted by the chaincode. Used only with Init or Invoke. // This event is then stored with Block.NonHashData.TransactionResult ChaincodeEvent * ChaincodeEvent ChannelId string // Protobuf marshalling fields XXX_NoUnkeyedLiteral struct {} XXX_unrecognized [] byte XXX_sizecache int32 } type ChaincodeEvent struct { ChaincodeId string Txid string EventName string Payload [] byte // Protobuf marshalling fields XXX_NoUnkeyedLiteral struct {} XXX_unrecognized [] byte XXX_sizecache int32 } The last event se is locally cached in the stub and if present, then added to the chaincode message by the Handler when composing the response ChaincodeMessage at the end of the execution of the handleInit(...) and handleTransaction(...) methods. // file: shim/stub.go // func ( s * ChaincodeStub ) SetEvent ( name string , payload [] byte ) error { if name == \"\" { return errors . New ( \"event name cannot be empty string\" ) } s . chaincodeEvent = & pb . ChaincodeEvent { EventName : name , Payload : payload } } // file: shim/handler.go // func ( h * Handler ) handleInit ( msg * pb . ChaincodeMessage ) ( * pb . ChaincodeMessage , error ) { ... . stub , err := newChaincodeStub ( h , msg . ChannelId , msg . Txid , input , msg . Proposal ) ... . res := h . cc . Init ( stub ) resBytes , err := proto . Marshal ( & res ) ... return & pb . ChaincodeMessage { Type : pb . ChaincodeMessage_COMPLETED , Payload : resBytes , Txid : msg . Txid , ChaincodeEvent : stub . chaincodeEvent , ChannelId : stub . ChannelID }, nil } Note The listing shows the implementation of the handleInit(....) method. The implementation of the of the handleTransaction(....) method is identical, except for the invocation of the h.cc.Invoke(stub) method.","title":"Implementation"},{"location":"shim-architecture/interaction-flow/overview/","text":"General Interaction Flow The figure below shows the interaction flow between the shim , the Handler and the Chaincode implementation during the processing of a transaction proposal. The message loop implemented in the chatWithPeer(....) method dispatches the message to the handler, which based on its state processes it. The most relevant path for this flows is the happening when the Handler is in the ready state and processes either transaction invocations via the handleStubInteraction(func(...), *ChaincodeMessage, chan<- error) method or responses to peer request by the chaincode via the handleResponse(*ChaincodeMessage) method. High-Level Interaction Flow This is a high-level overview of the interaction inside the chaincocde process. In this section we will be covering the details of this interaction that allow for: concurrent processing of multiple transaction proposals; and communication back ton the peer for ledger request and cross-chaincode invocation. In particular we will be discussing the concucrrency model that enabling this behaviour and discuss some insights on the expected properties of the Chaincode implementation that this model requires for its correct operations.","title":"Overview"},{"location":"shim-architecture/interaction-flow/overview/#general-interaction-flow","text":"The figure below shows the interaction flow between the shim , the Handler and the Chaincode implementation during the processing of a transaction proposal. The message loop implemented in the chatWithPeer(....) method dispatches the message to the handler, which based on its state processes it. The most relevant path for this flows is the happening when the Handler is in the ready state and processes either transaction invocations via the handleStubInteraction(func(...), *ChaincodeMessage, chan<- error) method or responses to peer request by the chaincode via the handleResponse(*ChaincodeMessage) method. High-Level Interaction Flow This is a high-level overview of the interaction inside the chaincocde process. In this section we will be covering the details of this interaction that allow for: concurrent processing of multiple transaction proposals; and communication back ton the peer for ledger request and cross-chaincode invocation. In particular we will be discussing the concucrrency model that enabling this behaviour and discuss some insights on the expected properties of the Chaincode implementation that this model requires for its correct operations.","title":"General Interaction Flow"},{"location":"shim-architecture/interaction-flow/range-queries/","text":"Range Queries and Iterators Overview The ChaincodeStubInterface exposes several methods that allow smart contract developers to retrieve a sequence of entries. This capability is quite useful as it allows, for instance, the iteration of a range of keys that match a certain criteria or retrieval of the historical changes made to the value associated to a key. The implementation of this capability relies on iterators . These rely upon the already described method for issuing requests to the peer but may involve multiple requests made to optimise the bandwidth and the consumption of network resources. Implementation Three different types of iterators are defined: CommonIteratorInterface : this interface defines the common operations of all types of iterators. StateQueryIteratorInterface : this interface specialises the base iterator interface to iterate over a collection of keys in the ledger. HistoryQueryIteratorInterface : this interface specialises the base iterator interface to iterate over the history of changes of a key. The listing below shows the definition of the iterator interfaces and the following table maps the ChaincodeStubInterface methods to the corresponding iterators that are returned by such methods. type CommonIteratorInterface interface { HasNext () bool Close () error } type { CommonIteratorInterface Next () ( * queryresult . KV , error ) } type HistoryQueryIteratorInterface { CommonIteratorInterface Next () ( * queryresult . KyModification , error ) } ChaincodeStubInterface Method Returned Iterator GetStateByRange StateQueryIteratorInterface GetStateByRangeWithPagination StateQueryIteratorInterface GetStateByPartialCompositeKey StateQueryIteratorInterface GetStateByPartialCompositeKeyWithPagination StateQueryIteratorInterface GetQueryResult StateQueryIteratorInterface GetQueryResultWithPagination StateQueryIteratorInterface GetPrivateDataByRange StateQueryIteratorInterface GetPrivateDataByPartialCompositeKey StateQueryIteratorInterface GetPrivateDataQueryResult StateQueryIteratorInterface GetHistoryForKey HistoryQueryIteratorInterface Most of the method use the StateQueryIteratorInterface as they provide different options to iterate over a collection of key in the world state (public and private). Only one method returns implementation of HistoryQueryIteratorInterface . These specialised interfaces of the CommonIteratorInterface only differ in the declaration of the return type of the Next() method. This is also reflected in the implementation of these interfaces that are defined in the stub.go file: CommonQueryIterator : implements all the common logic of the iterator and the interaction with the handler. StateQueryIterator : implements the Next() method to cast the returned struct to the *queryresult.KV type. HistoryQueryIterator : implements the Next() method to cast the returned struct to the *queryresult.KeyModification type. The coordination of these three component with the ChaincodeStub provides support fo all the functions that return iterators. The ChaincodeStub has the following responsibilities: prepare the information about the range to be queried, by adapting the parameters passed to the different methods that return iterators; invoke the corresponding Handler method to retrieve the first batch of data; and return the appropriate iterator implementation configured with the data that has been retrieved. The iteration control logic is all implemented in the method that are bound to the CommonIterator struct, while the other two struct simply type casting. The figure below provides an overview of the three structs and how the method bounds to the different types relate to each other. Design and Implementation of Iterators Interaction Flow The interaction flow with iterators starts from the ChaincodeStub , whose primaru responsibility is interfacing with the Chaincode implementation and expose a rich set of functions to query various elements in the ledger. From an implementation perspective all these functions are supported by three key methods: ChaincodeStub.handleGetStateByRange(....) ChaincodeStub.handleGetQueryResult(....) ChaincodeStub.createQueryMetadata(....) Moreover, a set of utility methods support the management of key ranges and are used to prepare the information required by these methods. Iterating Over State Keys The method ChaincodeStub.handleGetStateByRange(....) is the common denominator for all those methods that retrieves a collection of keys from the ledger. These are: ChaincodeStubInterface.GetStateByRange(...) ChaincodeStubInterface.GetStateByRangeWithPagination(...) ChaincodeStubInterface.GetStateByPartialCompositeKey(...) ChaincodeStubInterface.GetStateByPartialCompositeKeyWithPagination(...) ChaincodeStubInterface.GetPrivateDataByRange(...) ChaincodeStubInterface.GetPrivateDataByPartialCompositeKey(...) This method invokes the corresponding function in the handler. This in turn sends a ChaincodeMessage of type GET_STATE_BY_RANGE configured with the required parameters to instruct the peer what to query. The listing below shows the implementation of the method. func ( s * ChaincodeStub ) handleGetStateByRange ( collection , startKey , endKey string , metadata [] byte ) ( StateQueryIteratorInterface , * pb . QueryResponseMetadata , error ) { response , err := s . handler . handleGetStateByRange ( collection , startKey , endKey , metadata , s . ChannelID , s . TxID ) if err != nil { return nil , nil , err } iterator := s . createStateQueryIterator ( response ) responseMetadata , err := createQueryResponseMetadata ( response . Metadata ) if err != nil { return nil , nil , err } return iterator , responseMetadata , nil } The most of the execution of the logic is contained in the handler. The stub is responsible for creating the appropriate iterator and deserialising the QueryResponseMetadata which provides information about the records that have been fetched and the bookmark for the search. Executing Complex Queries The execution of complex queries is implemented through ChaincodeStub.handleGetQueryResult(...) which supports the functionalities required by the following methods: ChaincodeStubInterface.GetQueryResult(...) ChaincodeStubInterface.GetQueryResultWithPagination(...) GetPrivateDataQueryResult(...) The implementation invokes the corresponding function in the handler. This in turn sends a ChaincodeMessage of type GET_QUERY_RESULT to the peer configured with the repquired parameter to instruct the peer on what to query. The implementation of this method is essentially the same as the one that support queries by range. func ( s * ChaincodeStub ) handleGetQueryResult ( collection , query string , metadata [] byte ) ( StateQueryIteratorInterface , * pb . QueryResponseMetadata , error ) { response , err := s . handler . handleGetQueryResult ( collection , query , metadata , s . ChannelID , s . TxID ) if err != nil { return nil , nil , err } iterator := s . createStateQueryIterator ( response ) responseMetadata , err := createQueryResponseMetadata ( response . Metadata ) if err != nil { return nil , nil , err } return iterator , responseMetadata , nil } Retrieving the History of a Key The method ChaincodeStub.GetHistoryForKey(...) provides access to the history of changes of a specific key in the ledger. The ChaincodeStubInterface exposes only one version of this method and therefore the coordination logic for retrieval is implemented directly in this method. In this case, there is no query metadata to process because there is no explicit pagination support as in the other two cases. func ( s * ChaincodeStub ) GetHistoryForKey ( key string ) ( StateQueryIteratorInterface , error ) { response , err := s . handler . handleGetHistoryForKey ( key , s . ChannelID , s . TxID ) if err != nil { return nil , err } return & HistoryQueryIterator { CommonIterator : & CommonIterator { s . handler , s . ChannelID , s . TxID , response , 0 }}, nil } This method invokes the corresponding method in the handler, which in turn sends a message GET_HISTORY_FOR_KEY to the peer to retrieve the history associated to the specified key. Pagination Control The figure below provides an overview of the iterator in action within the context of the chaincode process. The figure shows the case for querying the ledger state by range, and therefore the execution of ChaincodeStub.handleGetStateByRange(...) but the flow is essentially the same for all the other methods that return iterators. Pagination Control with Iterators A normal iteration cycle includes the following: invoking HasNext() to verify whether there are more elements to process; in case there are invoking Next() to retrieve the next element; and in case there aren't, close the iterator by invoking Close() . The first two operation can be repeated in sequence until the caller is satisfied with the value that have been returned of the iterator reaches the end of the range. Internally, the iterator implementation feeds the caller with element from the local batch of data that has been pre-fetched. If the iterator has reached the last element of the local batch, the iterator invokes fetchNextQueryResult() , which in turn calls the method Handler.handleNextQueryStateNext(...) by passing to it the last key that has been retrieved. The handler utilises this information to create a ChaincodeMessage of type QUERY_STATE_NEXT to the peer to retrieve the next batch of items. The call to the handler method is blocking because the implementation uses Handler.sendReceive(....) and therefore it behaves as previously explained. Similarly, closing an iterator triggers the invocation of Handler.handleQueryStateClose(..) which sends a message of type QU?ERY_STATE_CLOSE to the peer and instruct it release the resources allocated to serve the query. The pagination control logic is fully implemented in the methods bound to the CommonIterator struct. Even the implementation of the Next() methods is controlled by the common iterator logic defined by CommonIterator.nextResult(...) which has a switch on type to handle the processing of the different types of data. The listing below shows the implementation of the relevant methods of the iterator. func ( iter * CommonIterator ) fetchNextQueryResult () error { response , err := iter . handler . handleQueryStateNext ( iter . response . Id , iter . channelID , iter . txid ) if err != nil { return err } iter . currentLoc = 0 iter . response = response return nil } func ( iter * CommonIterator ) getResultFromBytes ( queryResultBytes * pb . QueryResultBytes , rType resultType ) ( queryResult , error ) { if rType == StateQueryResult { stateQueryResult := & queryresult . KV {} if err := proto . Unmarshal ( queryResultBytes . ResultBytes , stateQueryResult ); err != nil { return nil , fmt . Errorf ( \"error unmarshaling result from bytes: %s\" , err ) } return stateQueryResult , nil } else if rType == HistoryQueryResult { historyQueryResult := & queryresult . KeyModification {} if err := proto . Unmarshal ( queryResultBytes . ResultBytes , historyQueryResult ); err != nil { return nil , err } return historyQueryResult , nil } return nil , errors . New ( \"wrong result type\" ) } func ( iter * CommonIterator ) nextResult ( rType resultType ) ( queryResult , error ) { if iter . currentLoc < len ( iter . response . Results ) { // On valid access of an element from cached results queryResult , err := iter . getResultFromBytes ( iter . response . Results [ iter . currentLoc ], rType ) if err != nil { return nil , err } iter . currentLoc ++ if iter . currentLoc == len ( iter . response . Results ) && iter . response . HasMore { // On access of last item, pre-fetch to update HasMore flag if err = iter . fetchNextQueryResult (); err != nil { return nil , err } } return queryResult , err } else if ! iter . response . HasMore { // On call to Next() without check of HasMore return nil , errors . New ( \"no such key\" ) } // should not fall through here // case: no cached results but HasMore is true. return nil , errors . New ( \"invalid iterator state\" ) } The method nextResult(...) is the one that controls the access to the local cache of elements and the iteration logic. It invokes getNextResultFromBytes(...) to deserialise the element to return into the right type, and pre-fetches the next batch of elements by invoking fetchNextQueryResult(...) . Observations From the implementation of these method every method that provides access to iterators returns iterator implementations that partially retrieve the set of elements that match the searching criteria in the form of data pages. This is the implemented behaviour regardless of whether the smart contract develoeper has called a method ...WithPagination(...) . The question therefore arise on what is the difference between the paginated version and the non-paginated version of the same method. The first set of methods implement explicit pagination while the second set of method rely upon implicit pagination . From an implementation perspective it is always useful to paginate large data sets, especially if there isn't a full consumption of the data in range. Methods that provide explicit pagination provide the smart contract developers with more control on the navigation of the range of keys that are returned by the iterator. For instance, it allows them to skip elements more easily and to start the search from a given page.","title":"Range Queries and Iterators"},{"location":"shim-architecture/interaction-flow/range-queries/#range-queries-and-iterators","text":"","title":"Range Queries and Iterators"},{"location":"shim-architecture/interaction-flow/range-queries/#overview","text":"The ChaincodeStubInterface exposes several methods that allow smart contract developers to retrieve a sequence of entries. This capability is quite useful as it allows, for instance, the iteration of a range of keys that match a certain criteria or retrieval of the historical changes made to the value associated to a key. The implementation of this capability relies on iterators . These rely upon the already described method for issuing requests to the peer but may involve multiple requests made to optimise the bandwidth and the consumption of network resources.","title":"Overview"},{"location":"shim-architecture/interaction-flow/range-queries/#implementation","text":"Three different types of iterators are defined: CommonIteratorInterface : this interface defines the common operations of all types of iterators. StateQueryIteratorInterface : this interface specialises the base iterator interface to iterate over a collection of keys in the ledger. HistoryQueryIteratorInterface : this interface specialises the base iterator interface to iterate over the history of changes of a key. The listing below shows the definition of the iterator interfaces and the following table maps the ChaincodeStubInterface methods to the corresponding iterators that are returned by such methods. type CommonIteratorInterface interface { HasNext () bool Close () error } type { CommonIteratorInterface Next () ( * queryresult . KV , error ) } type HistoryQueryIteratorInterface { CommonIteratorInterface Next () ( * queryresult . KyModification , error ) } ChaincodeStubInterface Method Returned Iterator GetStateByRange StateQueryIteratorInterface GetStateByRangeWithPagination StateQueryIteratorInterface GetStateByPartialCompositeKey StateQueryIteratorInterface GetStateByPartialCompositeKeyWithPagination StateQueryIteratorInterface GetQueryResult StateQueryIteratorInterface GetQueryResultWithPagination StateQueryIteratorInterface GetPrivateDataByRange StateQueryIteratorInterface GetPrivateDataByPartialCompositeKey StateQueryIteratorInterface GetPrivateDataQueryResult StateQueryIteratorInterface GetHistoryForKey HistoryQueryIteratorInterface Most of the method use the StateQueryIteratorInterface as they provide different options to iterate over a collection of key in the world state (public and private). Only one method returns implementation of HistoryQueryIteratorInterface . These specialised interfaces of the CommonIteratorInterface only differ in the declaration of the return type of the Next() method. This is also reflected in the implementation of these interfaces that are defined in the stub.go file: CommonQueryIterator : implements all the common logic of the iterator and the interaction with the handler. StateQueryIterator : implements the Next() method to cast the returned struct to the *queryresult.KV type. HistoryQueryIterator : implements the Next() method to cast the returned struct to the *queryresult.KeyModification type. The coordination of these three component with the ChaincodeStub provides support fo all the functions that return iterators. The ChaincodeStub has the following responsibilities: prepare the information about the range to be queried, by adapting the parameters passed to the different methods that return iterators; invoke the corresponding Handler method to retrieve the first batch of data; and return the appropriate iterator implementation configured with the data that has been retrieved. The iteration control logic is all implemented in the method that are bound to the CommonIterator struct, while the other two struct simply type casting. The figure below provides an overview of the three structs and how the method bounds to the different types relate to each other. Design and Implementation of Iterators","title":"Implementation"},{"location":"shim-architecture/interaction-flow/range-queries/#interaction-flow","text":"The interaction flow with iterators starts from the ChaincodeStub , whose primaru responsibility is interfacing with the Chaincode implementation and expose a rich set of functions to query various elements in the ledger. From an implementation perspective all these functions are supported by three key methods: ChaincodeStub.handleGetStateByRange(....) ChaincodeStub.handleGetQueryResult(....) ChaincodeStub.createQueryMetadata(....) Moreover, a set of utility methods support the management of key ranges and are used to prepare the information required by these methods.","title":"Interaction Flow"},{"location":"shim-architecture/interaction-flow/range-queries/#iterating-over-state-keys","text":"The method ChaincodeStub.handleGetStateByRange(....) is the common denominator for all those methods that retrieves a collection of keys from the ledger. These are: ChaincodeStubInterface.GetStateByRange(...) ChaincodeStubInterface.GetStateByRangeWithPagination(...) ChaincodeStubInterface.GetStateByPartialCompositeKey(...) ChaincodeStubInterface.GetStateByPartialCompositeKeyWithPagination(...) ChaincodeStubInterface.GetPrivateDataByRange(...) ChaincodeStubInterface.GetPrivateDataByPartialCompositeKey(...) This method invokes the corresponding function in the handler. This in turn sends a ChaincodeMessage of type GET_STATE_BY_RANGE configured with the required parameters to instruct the peer what to query. The listing below shows the implementation of the method. func ( s * ChaincodeStub ) handleGetStateByRange ( collection , startKey , endKey string , metadata [] byte ) ( StateQueryIteratorInterface , * pb . QueryResponseMetadata , error ) { response , err := s . handler . handleGetStateByRange ( collection , startKey , endKey , metadata , s . ChannelID , s . TxID ) if err != nil { return nil , nil , err } iterator := s . createStateQueryIterator ( response ) responseMetadata , err := createQueryResponseMetadata ( response . Metadata ) if err != nil { return nil , nil , err } return iterator , responseMetadata , nil } The most of the execution of the logic is contained in the handler. The stub is responsible for creating the appropriate iterator and deserialising the QueryResponseMetadata which provides information about the records that have been fetched and the bookmark for the search.","title":"Iterating Over State Keys"},{"location":"shim-architecture/interaction-flow/range-queries/#executing-complex-queries","text":"The execution of complex queries is implemented through ChaincodeStub.handleGetQueryResult(...) which supports the functionalities required by the following methods: ChaincodeStubInterface.GetQueryResult(...) ChaincodeStubInterface.GetQueryResultWithPagination(...) GetPrivateDataQueryResult(...) The implementation invokes the corresponding function in the handler. This in turn sends a ChaincodeMessage of type GET_QUERY_RESULT to the peer configured with the repquired parameter to instruct the peer on what to query. The implementation of this method is essentially the same as the one that support queries by range. func ( s * ChaincodeStub ) handleGetQueryResult ( collection , query string , metadata [] byte ) ( StateQueryIteratorInterface , * pb . QueryResponseMetadata , error ) { response , err := s . handler . handleGetQueryResult ( collection , query , metadata , s . ChannelID , s . TxID ) if err != nil { return nil , nil , err } iterator := s . createStateQueryIterator ( response ) responseMetadata , err := createQueryResponseMetadata ( response . Metadata ) if err != nil { return nil , nil , err } return iterator , responseMetadata , nil }","title":"Executing Complex Queries"},{"location":"shim-architecture/interaction-flow/range-queries/#retrieving-the-history-of-a-key","text":"The method ChaincodeStub.GetHistoryForKey(...) provides access to the history of changes of a specific key in the ledger. The ChaincodeStubInterface exposes only one version of this method and therefore the coordination logic for retrieval is implemented directly in this method. In this case, there is no query metadata to process because there is no explicit pagination support as in the other two cases. func ( s * ChaincodeStub ) GetHistoryForKey ( key string ) ( StateQueryIteratorInterface , error ) { response , err := s . handler . handleGetHistoryForKey ( key , s . ChannelID , s . TxID ) if err != nil { return nil , err } return & HistoryQueryIterator { CommonIterator : & CommonIterator { s . handler , s . ChannelID , s . TxID , response , 0 }}, nil } This method invokes the corresponding method in the handler, which in turn sends a message GET_HISTORY_FOR_KEY to the peer to retrieve the history associated to the specified key.","title":"Retrieving the History of a Key"},{"location":"shim-architecture/interaction-flow/range-queries/#pagination-control","text":"The figure below provides an overview of the iterator in action within the context of the chaincode process. The figure shows the case for querying the ledger state by range, and therefore the execution of ChaincodeStub.handleGetStateByRange(...) but the flow is essentially the same for all the other methods that return iterators. Pagination Control with Iterators A normal iteration cycle includes the following: invoking HasNext() to verify whether there are more elements to process; in case there are invoking Next() to retrieve the next element; and in case there aren't, close the iterator by invoking Close() . The first two operation can be repeated in sequence until the caller is satisfied with the value that have been returned of the iterator reaches the end of the range. Internally, the iterator implementation feeds the caller with element from the local batch of data that has been pre-fetched. If the iterator has reached the last element of the local batch, the iterator invokes fetchNextQueryResult() , which in turn calls the method Handler.handleNextQueryStateNext(...) by passing to it the last key that has been retrieved. The handler utilises this information to create a ChaincodeMessage of type QUERY_STATE_NEXT to the peer to retrieve the next batch of items. The call to the handler method is blocking because the implementation uses Handler.sendReceive(....) and therefore it behaves as previously explained. Similarly, closing an iterator triggers the invocation of Handler.handleQueryStateClose(..) which sends a message of type QU?ERY_STATE_CLOSE to the peer and instruct it release the resources allocated to serve the query. The pagination control logic is fully implemented in the methods bound to the CommonIterator struct. Even the implementation of the Next() methods is controlled by the common iterator logic defined by CommonIterator.nextResult(...) which has a switch on type to handle the processing of the different types of data. The listing below shows the implementation of the relevant methods of the iterator. func ( iter * CommonIterator ) fetchNextQueryResult () error { response , err := iter . handler . handleQueryStateNext ( iter . response . Id , iter . channelID , iter . txid ) if err != nil { return err } iter . currentLoc = 0 iter . response = response return nil } func ( iter * CommonIterator ) getResultFromBytes ( queryResultBytes * pb . QueryResultBytes , rType resultType ) ( queryResult , error ) { if rType == StateQueryResult { stateQueryResult := & queryresult . KV {} if err := proto . Unmarshal ( queryResultBytes . ResultBytes , stateQueryResult ); err != nil { return nil , fmt . Errorf ( \"error unmarshaling result from bytes: %s\" , err ) } return stateQueryResult , nil } else if rType == HistoryQueryResult { historyQueryResult := & queryresult . KeyModification {} if err := proto . Unmarshal ( queryResultBytes . ResultBytes , historyQueryResult ); err != nil { return nil , err } return historyQueryResult , nil } return nil , errors . New ( \"wrong result type\" ) } func ( iter * CommonIterator ) nextResult ( rType resultType ) ( queryResult , error ) { if iter . currentLoc < len ( iter . response . Results ) { // On valid access of an element from cached results queryResult , err := iter . getResultFromBytes ( iter . response . Results [ iter . currentLoc ], rType ) if err != nil { return nil , err } iter . currentLoc ++ if iter . currentLoc == len ( iter . response . Results ) && iter . response . HasMore { // On access of last item, pre-fetch to update HasMore flag if err = iter . fetchNextQueryResult (); err != nil { return nil , err } } return queryResult , err } else if ! iter . response . HasMore { // On call to Next() without check of HasMore return nil , errors . New ( \"no such key\" ) } // should not fall through here // case: no cached results but HasMore is true. return nil , errors . New ( \"invalid iterator state\" ) } The method nextResult(...) is the one that controls the access to the local cache of elements and the iteration logic. It invokes getNextResultFromBytes(...) to deserialise the element to return into the right type, and pre-fetches the next batch of elements by invoking fetchNextQueryResult(...) .","title":"Pagination Control"},{"location":"shim-architecture/interaction-flow/range-queries/#observations","text":"From the implementation of these method every method that provides access to iterators returns iterator implementations that partially retrieve the set of elements that match the searching criteria in the form of data pages. This is the implemented behaviour regardless of whether the smart contract develoeper has called a method ...WithPagination(...) . The question therefore arise on what is the difference between the paginated version and the non-paginated version of the same method. The first set of methods implement explicit pagination while the second set of method rely upon implicit pagination . From an implementation perspective it is always useful to paginate large data sets, especially if there isn't a full consumption of the data in range. Methods that provide explicit pagination provide the smart contract developers with more control on the navigation of the range of keys that are returned by the iterator. For instance, it allows them to skip elements more easily and to start the search from a given page.","title":"Observations"},{"location":"shim-architecture/interaction-flow/talk-backs/","text":"Managing Talk-backs with the Peer Scope and Functionalities A common requirement of the smart contract developers is to be able to query the ledger within the context of a transaction, either to reader from or write into it. The design of the smart contract is essentially stateless and therefore, any additional information that does not come with the chaincode arguments must be read from the ledger. The same goes for information that need to be persisted across transaction invocation that is not returned within a transaction proposal response payload. Besides, accessing the ledger a smart contract may invoke another chaincode function deployed on the same peer. This invocation is mediated by the peer and therefore requires a communication back to it within the context of a single transaction invocation. Managing Response Channels The communication is coordinated through ad-hoc channels that are created for each interaction back to the peer. This coordination is responsibility of the Handler and it is implemented in the method callPeerWithChaincodeMsg(...) shown in the listing below. This method is the common denominator of all the functions that are exposed by the ChaincodeStubInteface that require interaction with the peer. func ( h * Handler ) callPeerWithChaincodeMsg ( msg * pb . ChaincodeMessage , channelID string , txid string ) ( * pb . ChaincodeMessage , error ) { respChan , err := h . createResponseChannel ( channelID , txid ) if err != nil { return pb . ChaincodeMessage {}, err } defer h . deleteResponseChannel ( channelID , txid ) return h . sendReceive ( msg , respChan ) } There are a couple of things here to observe: the method creates a response channel which is a go structure used to synchronise different go-routines and pass information among them; it then invokes the method sendReceive(...) waits until a response from the peer is received; and it finally deletes the response channel just created, at the completion of the method execution. The response channels are indexed by providing the information about the channel and the transaction identifier. This can be inferred by the parameters passed to the createResponseChannel(....) and deleteResponseChannel(...) methods above and shown in the listing below. func ( h * Handler ) createResponsechannel ( channelID string , txid string ) ( * pb . ChaincodeMessage , error ) { h . responseChannelMutex . Lock () defer h . responseChannelMutex . Unlock () if h . responseChannels == nil { return nil , fmt . Errorf ( \"[%s] cannot create response channel\" , shorttxid ( txid )) } txCtxID := transactionContextID ( channelID , txid ) if h . responseChannels [ txCtxID ] != nil { return nil , fmt . Errorf ( \"[%s] channel exists\" , shorttxid ( txid )) } responseChan := make ( chan pb . ChaincodeMessage ) h . responseChannels [ txCtxID ] = responseChan return responseChan , nil } func ( h * Handler ) deleteResponsechannel ( channelID string , txid string ) { h . responseChannelMutex . Lock () defer h . responseChannelMutex . Unlock () if h . responseChannels != nil { txCtxID := transactionContextID ( channelID , txid ) delete ( h . responseChannels , txCtxID ) } } The transaction context identifier (i.e. txCtxID ) is created by the transactionContextID(...) function that simply combines into a single string tthe channel identifier and the transaction identifier. This identifier is used as key to index the responseChannels map structure of the handler and map the channel that will be used to receive chaincode messages from the message dispatching loop via Handler.handleResponse(...) . Because the map is accessed from concurrent go-routines, its access and update is wrapped within a mutex. The listing below shows the implementation of the of the sendReceive(...) method shows how the go-routine executing the transaction proposal simulation waits on the channel responseChan until it can read a ChaincodeMessage instance representing the response obtained from the peer. func ( h * Handler ) sendReceive ( msg * pb . ChaincodeMessage , responseChan <- chan pb . ChaincodeMessage ) ( pb . ChaincodeMessage , error ) { err := h . serialSend ( msg ) if err != nil { return pb . ChaincodeMessage {}, err } outMsg := <- responseChan return outMsg , nil } Detecting Responses from Message Stream The reception of any message coming from the peer is implemented in short-lived go-routines that are spawn by the main thread which control the message receiving loop. The loop passes the all the received messages to the Handler.handleMessage(*ChaincodeMessage) , which based on the current state of the handler dispatches the processing to the appropriate handler function. In this case we are interested in the Handler.handleReady(*ChaincodeMessage) function, and more precisely in the Handler.handleResponse(*ChaincodeMessage) method, shown in the listing below. This method is invoked for both RESPONSE and ERROR type messages that identify responses of the peer to a chaincode request. func ( h * Handler ) handleResponse ( msg * pb . ChaincodeMessage ) error { h . responseChannelsMutex . Lock () defer h . responseChannelsMutex . Unlock () if h . responseChannels == nil { return fmt . Errorf ( \"[%s] Cannot send message response channel\" , shorttxid ( msg . Txid )) } txCtxID := transactionContextID ( msg . ChannelId , msg . Txid ) responseCh := h . responseChannels [ txCtxID ] if responseCh == nil { return fmt . Errorf ( \"[%s] responseChannel does not exist\" , shorttxid ( msg . Txid )) } responseCh <- * msg return nil } This method reconstructs the transaction context identifier by using the information about the channel and the transaction identifiers exposed by the chaincode message, retrieves the corresponding response channel from the responseChannels map and pushes the message through the channel to unblock the waiting go-routine that is executing the transaction propsoal simulation to invoked the peer. Once unblocked, the sendReceive(...) method completes, the callPeerWithChaincodeMsg(....) method completes, deletes the response channel and eventually the control is returned to the chaincode implementation to continue the execution of the transaction. The figure below, provide a visual overview of the essential steps that occur during a transaction invocation that talks back to the peer. Transaction Invocation with Talk Back Observations The particular approach taken to the management of the response channel imposes some restrictions on the behaviour and the execution logic of the chaincode implementation. Since response channels are indexed by the pair of channel and transaction identifiers, there can be only one outgoing communication to the peer within the context of single transaction invocation at any given time . If there were more than one the current implementation would not be able to discern which message to send to which waiting go-routine, because the would share the same response channel. The problem does not sussist once the one request to the peer is fullfilled because at that point the corresponding response channel is deleted and therefore it can be recreated. This constraint translates into the requirement of serialising all the requests back to the peer, within the context of a transaction invocation. Essentially, all the requests made by the smart contract to the peer need to be made sequentially and we cannot trigger them concurrently. As a result, besides having a stateless model we also derive that the smart contract implementation should be single-threaded (i.e. it cannot spawn go-routines to execute functions with a reference to the ChaincodeStubInteface ). This is a very pragmatic reason for not using go-routines within a smart contract function. Obviously, avoiding non-determinism is another one equally important.","title":"Managing Talk-backs with the Peer"},{"location":"shim-architecture/interaction-flow/talk-backs/#managing-talk-backs-with-the-peer","text":"","title":"Managing Talk-backs with the Peer"},{"location":"shim-architecture/interaction-flow/talk-backs/#scope-and-functionalities","text":"A common requirement of the smart contract developers is to be able to query the ledger within the context of a transaction, either to reader from or write into it. The design of the smart contract is essentially stateless and therefore, any additional information that does not come with the chaincode arguments must be read from the ledger. The same goes for information that need to be persisted across transaction invocation that is not returned within a transaction proposal response payload. Besides, accessing the ledger a smart contract may invoke another chaincode function deployed on the same peer. This invocation is mediated by the peer and therefore requires a communication back to it within the context of a single transaction invocation.","title":"Scope and Functionalities"},{"location":"shim-architecture/interaction-flow/talk-backs/#managing-response-channels","text":"The communication is coordinated through ad-hoc channels that are created for each interaction back to the peer. This coordination is responsibility of the Handler and it is implemented in the method callPeerWithChaincodeMsg(...) shown in the listing below. This method is the common denominator of all the functions that are exposed by the ChaincodeStubInteface that require interaction with the peer. func ( h * Handler ) callPeerWithChaincodeMsg ( msg * pb . ChaincodeMessage , channelID string , txid string ) ( * pb . ChaincodeMessage , error ) { respChan , err := h . createResponseChannel ( channelID , txid ) if err != nil { return pb . ChaincodeMessage {}, err } defer h . deleteResponseChannel ( channelID , txid ) return h . sendReceive ( msg , respChan ) } There are a couple of things here to observe: the method creates a response channel which is a go structure used to synchronise different go-routines and pass information among them; it then invokes the method sendReceive(...) waits until a response from the peer is received; and it finally deletes the response channel just created, at the completion of the method execution. The response channels are indexed by providing the information about the channel and the transaction identifier. This can be inferred by the parameters passed to the createResponseChannel(....) and deleteResponseChannel(...) methods above and shown in the listing below. func ( h * Handler ) createResponsechannel ( channelID string , txid string ) ( * pb . ChaincodeMessage , error ) { h . responseChannelMutex . Lock () defer h . responseChannelMutex . Unlock () if h . responseChannels == nil { return nil , fmt . Errorf ( \"[%s] cannot create response channel\" , shorttxid ( txid )) } txCtxID := transactionContextID ( channelID , txid ) if h . responseChannels [ txCtxID ] != nil { return nil , fmt . Errorf ( \"[%s] channel exists\" , shorttxid ( txid )) } responseChan := make ( chan pb . ChaincodeMessage ) h . responseChannels [ txCtxID ] = responseChan return responseChan , nil } func ( h * Handler ) deleteResponsechannel ( channelID string , txid string ) { h . responseChannelMutex . Lock () defer h . responseChannelMutex . Unlock () if h . responseChannels != nil { txCtxID := transactionContextID ( channelID , txid ) delete ( h . responseChannels , txCtxID ) } } The transaction context identifier (i.e. txCtxID ) is created by the transactionContextID(...) function that simply combines into a single string tthe channel identifier and the transaction identifier. This identifier is used as key to index the responseChannels map structure of the handler and map the channel that will be used to receive chaincode messages from the message dispatching loop via Handler.handleResponse(...) . Because the map is accessed from concurrent go-routines, its access and update is wrapped within a mutex. The listing below shows the implementation of the of the sendReceive(...) method shows how the go-routine executing the transaction proposal simulation waits on the channel responseChan until it can read a ChaincodeMessage instance representing the response obtained from the peer. func ( h * Handler ) sendReceive ( msg * pb . ChaincodeMessage , responseChan <- chan pb . ChaincodeMessage ) ( pb . ChaincodeMessage , error ) { err := h . serialSend ( msg ) if err != nil { return pb . ChaincodeMessage {}, err } outMsg := <- responseChan return outMsg , nil }","title":"Managing Response Channels"},{"location":"shim-architecture/interaction-flow/talk-backs/#detecting-responses-from-message-stream","text":"The reception of any message coming from the peer is implemented in short-lived go-routines that are spawn by the main thread which control the message receiving loop. The loop passes the all the received messages to the Handler.handleMessage(*ChaincodeMessage) , which based on the current state of the handler dispatches the processing to the appropriate handler function. In this case we are interested in the Handler.handleReady(*ChaincodeMessage) function, and more precisely in the Handler.handleResponse(*ChaincodeMessage) method, shown in the listing below. This method is invoked for both RESPONSE and ERROR type messages that identify responses of the peer to a chaincode request. func ( h * Handler ) handleResponse ( msg * pb . ChaincodeMessage ) error { h . responseChannelsMutex . Lock () defer h . responseChannelsMutex . Unlock () if h . responseChannels == nil { return fmt . Errorf ( \"[%s] Cannot send message response channel\" , shorttxid ( msg . Txid )) } txCtxID := transactionContextID ( msg . ChannelId , msg . Txid ) responseCh := h . responseChannels [ txCtxID ] if responseCh == nil { return fmt . Errorf ( \"[%s] responseChannel does not exist\" , shorttxid ( msg . Txid )) } responseCh <- * msg return nil } This method reconstructs the transaction context identifier by using the information about the channel and the transaction identifiers exposed by the chaincode message, retrieves the corresponding response channel from the responseChannels map and pushes the message through the channel to unblock the waiting go-routine that is executing the transaction propsoal simulation to invoked the peer. Once unblocked, the sendReceive(...) method completes, the callPeerWithChaincodeMsg(....) method completes, deletes the response channel and eventually the control is returned to the chaincode implementation to continue the execution of the transaction. The figure below, provide a visual overview of the essential steps that occur during a transaction invocation that talks back to the peer. Transaction Invocation with Talk Back","title":"Detecting Responses from Message Stream"},{"location":"shim-architecture/interaction-flow/talk-backs/#observations","text":"The particular approach taken to the management of the response channel imposes some restrictions on the behaviour and the execution logic of the chaincode implementation. Since response channels are indexed by the pair of channel and transaction identifiers, there can be only one outgoing communication to the peer within the context of single transaction invocation at any given time . If there were more than one the current implementation would not be able to discern which message to send to which waiting go-routine, because the would share the same response channel. The problem does not sussist once the one request to the peer is fullfilled because at that point the corresponding response channel is deleted and therefore it can be recreated. This constraint translates into the requirement of serialising all the requests back to the peer, within the context of a transaction invocation. Essentially, all the requests made by the smart contract to the peer need to be made sequentially and we cannot trigger them concurrently. As a result, besides having a stateless model we also derive that the smart contract implementation should be single-threaded (i.e. it cannot spawn go-routines to execute functions with a reference to the ChaincodeStubInteface ). This is a very pragmatic reason for not using go-routines within a smart contract function. Obviously, avoiding non-determinism is another one equally important.","title":"Observations"},{"location":"shim-architecture/interaction-flow/transaction-processing/","text":"Asynchronous Transaction Processing Concurrency Model The figure shows a view of the concurrency model implemented in the shim. For the sake of simplicity the different execution paths that are run concurrently are referred as threads regardless of their underlying implementation (i.e. green threads, go-routines, ..). Within this context the term is used simply to refer to a function executed concurrently with others. Interaction Flow - Threading Model View There are three main threads that define the flow: Main Thread : this thread executes the entrypoint of the chaincode process, it is responsible for its initialisation and implements the infinite loop that dispatches the messages to the handler. This thread is responsible for the life-cycle of the overall process and if any unexpected error is detected in the reception of messages or the processing of proposals it terminates the process. The execution relies on two channels to: errc and msgAvail from which both incoming messages and errors are communicated to this thread. Message Receiving Thread : this thread executes the receiveMessage() function which listens to the bidirectional stream established with the peer and deserialises incoming data into the form of ChaincodeMessage instances. These are then pushed through the msgAvail channel to the main thread for further processing. Both valid data and error are passed through the msgAvail channel. Transaction Execution Thread : this thread executes the transaction proposal simulation, either via invoking Handler.handleInit(*ChaincodeMessage) or Handler.handleTransaction(*ChaincodeMessage) . Note The figure does not show the scenario where the execution of the chaincode methods results in requests made to the peer. In this case there is another short lived thread that is used to send a message through the bidirectional stream. This function is implemented in the Handler.serialSendAsync(*ChaincodeMessage,chan <- error) , which simply executes in a go routine the Handler.serialSend(*ChaincodeMessage) function and pushes any error in the provided channel. This execution model allows the chaincode process to increase the throughput of as transaction proposals are executed asynchronously thus leaving the main thread free to process other requests. Moreover, it also minimises the duration of the asychronous execution paths that operate on the bidirectional stream, since the receiveMessage() function only lives for the time required to process one message. This is quite relevant since the stream is used to both send and receive messages from different threads. Execution of Transaction Proposal The most interesting part of the interaction flow is the execution of transaction proposal. The listing below shows the implementation of the Handler.handleReady(...) method, which performs the dispatch of the messages based on their type to the appropriate handler function. func ( h * Handler ) handleReady ( msg * p . ChaincodeMessage , errc chan error ) error { switch msg . Type { case pb . ChaincodeMessage_RESPONSE , pb . ChaincodeMessage_ERROR : if err := h . handleResponse ( msg ); err != nil { return err } return nil case pb . ChaincodeMessage_INIT : go h . handleStubInteraction ( h . handleInit , msg , errc ) return nil case pb . ChaincodeMessage_TRANSACTION : go h . handleStubInteraction ( h . handleTransaction , msg , errc ) return nil default : return fmt . Errorf ( \"[%s] Chaincode h cannot handle message (%s) while in state: %s\" , msg . Txid , msg . Type , h . state ) } } Three different cases are handled, and only two result in the asychronous execution of the chaincode methods, while the processing of RESPONSE messages from the peer is managed within the same thread. The execution of transaction proposal is managed in the Handler.handleStubInteraction(...) which takes a function as argument, the ChaincodeMessage to process, and a reference to the error channel. The responsibility of this function is primarily error management and asynchronous communication back to the peer, the processing of the message is left to the handler function passed as first argument. This is what differentiates the execution of the INIT or the TRANSACTION proposals. func ( h * Handler ) handleStubInteration ( handler handleStubFunc , msg * p . ChaincodeMessage , errc chan <- error ){ resp , err := handler ( msg ) if err != nil { resp = & pb . ChaincodeMessage { Type : pb . ChaincodeMessage_ERROR , Payload : [] byte ( err . Error (), Txid : msg . Txid , ChannelId : msg . ChannelId } } h . serialSendAsync ( resp , errc ) } The processing of the two types of proposals is left to the following functions: func ( h * Handler ) handleInit ( msg * pb . ChaincodeMessage ) ( * pb . ChaincodeMessage , error ){ ... } func ( h * Handler ) handleTransaction ( msg * pb . ChaincodeMessage ) ( * pb . ChaincodeMessage , error ){ ... } These function have essentially the same logic comprising the following steps: deserialisation (unmarshalling) of the ChaincodeInput instance from the ChaincodeMessage payload; creation of a new instance of the ChaincodeStub and configuration of the transaction context comprising of channel identifier, transaction identifier, input (i.e. ChaincodeInput ) and signed proposal; and invocation of the Chaincode.Init(ChaincodeStub) or Chaincode.Invoke(ChaincodeStub) method. If there is an invocation error the method will return a ChaincodeMessage of type ERROR , if the execution is successful it will return a message of type COMPLETED containing the response produced by the chaincode.","title":"Aysnchronous Transaction Processing"},{"location":"shim-architecture/interaction-flow/transaction-processing/#asynchronous-transaction-processing","text":"","title":"Asynchronous Transaction Processing"},{"location":"shim-architecture/interaction-flow/transaction-processing/#concurrency-model","text":"The figure shows a view of the concurrency model implemented in the shim. For the sake of simplicity the different execution paths that are run concurrently are referred as threads regardless of their underlying implementation (i.e. green threads, go-routines, ..). Within this context the term is used simply to refer to a function executed concurrently with others. Interaction Flow - Threading Model View There are three main threads that define the flow: Main Thread : this thread executes the entrypoint of the chaincode process, it is responsible for its initialisation and implements the infinite loop that dispatches the messages to the handler. This thread is responsible for the life-cycle of the overall process and if any unexpected error is detected in the reception of messages or the processing of proposals it terminates the process. The execution relies on two channels to: errc and msgAvail from which both incoming messages and errors are communicated to this thread. Message Receiving Thread : this thread executes the receiveMessage() function which listens to the bidirectional stream established with the peer and deserialises incoming data into the form of ChaincodeMessage instances. These are then pushed through the msgAvail channel to the main thread for further processing. Both valid data and error are passed through the msgAvail channel. Transaction Execution Thread : this thread executes the transaction proposal simulation, either via invoking Handler.handleInit(*ChaincodeMessage) or Handler.handleTransaction(*ChaincodeMessage) . Note The figure does not show the scenario where the execution of the chaincode methods results in requests made to the peer. In this case there is another short lived thread that is used to send a message through the bidirectional stream. This function is implemented in the Handler.serialSendAsync(*ChaincodeMessage,chan <- error) , which simply executes in a go routine the Handler.serialSend(*ChaincodeMessage) function and pushes any error in the provided channel. This execution model allows the chaincode process to increase the throughput of as transaction proposals are executed asynchronously thus leaving the main thread free to process other requests. Moreover, it also minimises the duration of the asychronous execution paths that operate on the bidirectional stream, since the receiveMessage() function only lives for the time required to process one message. This is quite relevant since the stream is used to both send and receive messages from different threads.","title":"Concurrency Model"},{"location":"shim-architecture/interaction-flow/transaction-processing/#execution-of-transaction-proposal","text":"The most interesting part of the interaction flow is the execution of transaction proposal. The listing below shows the implementation of the Handler.handleReady(...) method, which performs the dispatch of the messages based on their type to the appropriate handler function. func ( h * Handler ) handleReady ( msg * p . ChaincodeMessage , errc chan error ) error { switch msg . Type { case pb . ChaincodeMessage_RESPONSE , pb . ChaincodeMessage_ERROR : if err := h . handleResponse ( msg ); err != nil { return err } return nil case pb . ChaincodeMessage_INIT : go h . handleStubInteraction ( h . handleInit , msg , errc ) return nil case pb . ChaincodeMessage_TRANSACTION : go h . handleStubInteraction ( h . handleTransaction , msg , errc ) return nil default : return fmt . Errorf ( \"[%s] Chaincode h cannot handle message (%s) while in state: %s\" , msg . Txid , msg . Type , h . state ) } } Three different cases are handled, and only two result in the asychronous execution of the chaincode methods, while the processing of RESPONSE messages from the peer is managed within the same thread. The execution of transaction proposal is managed in the Handler.handleStubInteraction(...) which takes a function as argument, the ChaincodeMessage to process, and a reference to the error channel. The responsibility of this function is primarily error management and asynchronous communication back to the peer, the processing of the message is left to the handler function passed as first argument. This is what differentiates the execution of the INIT or the TRANSACTION proposals. func ( h * Handler ) handleStubInteration ( handler handleStubFunc , msg * p . ChaincodeMessage , errc chan <- error ){ resp , err := handler ( msg ) if err != nil { resp = & pb . ChaincodeMessage { Type : pb . ChaincodeMessage_ERROR , Payload : [] byte ( err . Error (), Txid : msg . Txid , ChannelId : msg . ChannelId } } h . serialSendAsync ( resp , errc ) } The processing of the two types of proposals is left to the following functions: func ( h * Handler ) handleInit ( msg * pb . ChaincodeMessage ) ( * pb . ChaincodeMessage , error ){ ... } func ( h * Handler ) handleTransaction ( msg * pb . ChaincodeMessage ) ( * pb . ChaincodeMessage , error ){ ... } These function have essentially the same logic comprising the following steps: deserialisation (unmarshalling) of the ChaincodeInput instance from the ChaincodeMessage payload; creation of a new instance of the ChaincodeStub and configuration of the transaction context comprising of channel identifier, transaction identifier, input (i.e. ChaincodeInput ) and signed proposal; and invocation of the Chaincode.Init(ChaincodeStub) or Chaincode.Invoke(ChaincodeStub) method. If there is an invocation error the method will return a ChaincodeMessage of type ERROR , if the execution is successful it will return a message of type COMPLETED containing the response produced by the chaincode.","title":"Execution of Transaction Proposal"}]}